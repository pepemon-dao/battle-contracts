{
  "language": "Solidity",
  "sources": {
    "contracts/cardlib/Address.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/cardlib/Base64.sol": {
      "content": "\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return '';\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {let i := 0} lt(i, len) {} {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n"
    },
    "contracts/cardlib/Context.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"
    },
    "contracts/cardlib/ERC1155.sol": {
      "content": "import \"./IERC1155Receiver.sol\";\r\nimport \"./IERC1155.sol\";\r\nimport \"./Address.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of Multi-Token Standard contract\r\n */\r\ncontract ERC1155 is IERC1155 {\r\n    using Address for address;\r\n\r\n\r\n    /***********************************|\r\n    |        Variables and Events       |\r\n    |__________________________________*/\r\n\r\n    // onReceive function signatures\r\n    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n    // Objects balances\r\n    mapping (address => mapping(uint256 => uint256)) internal balances;\r\n\r\n    // Operator Functions\r\n    mapping (address => mapping(address => bool)) internal operators;\r\n\r\n\r\n    /***********************************|\r\n    |     Public Transfer Functions     |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * @notice Transfers amount amount of an _id from the _from address to the _to address specified\r\n     * @param _from    Source address\r\n     * @param _to      Target address\r\n     * @param _id      ID of the token type\r\n     * @param _amount  Transfered amount\r\n     * @param _data    Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    public override\r\n    {\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\r\n        require(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\r\n        // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\r\n\r\n        _safeTransferFrom(_from, _to, _id, _amount);\r\n        _callonERC1155Received(_from, _to, _id, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n     * @param _from     Source addresses\r\n     * @param _to       Target addresses\r\n     * @param _ids      IDs of each token type\r\n     * @param _amounts  Transfer amounts per token type\r\n     * @param _data     Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    public override\r\n    {\r\n        // Requirements\r\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\r\n        require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\r\n\r\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\r\n        _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\r\n    }\r\n\r\n\r\n    /***********************************|\r\n    |    Internal Transfer Functions    |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * @notice Transfers amount amount of an _id from the _from address to the _to address specified\r\n     * @param _from    Source address\r\n     * @param _to      Target address\r\n     * @param _id      ID of the token type\r\n     * @param _amount  Transfered amount\r\n     */\r\n    function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\r\n    internal \r\n    {\r\n        // Update balances\r\n        balances[_from][_id] = balances[_from][_id]-_amount; // Subtract amount\r\n        balances[_to][_id] = balances[_to][_id]+_amount;     // Add amount\r\n\r\n        // Emit event\r\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\r\n     */\r\n    function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    internal \r\n    {\r\n        // Check if recipient is contract\r\n        if (_to.isContract()) {\r\n            bytes4 retval = IERC1155Receiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\r\n            require(retval == ERC1155_RECEIVED_VALUE, \"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n     * @param _from     Source addresses\r\n     * @param _to       Target addresses\r\n     * @param _ids      IDs of each token type\r\n     * @param _amounts  Transfer amounts per token type\r\n     */\r\n    function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\r\n    internal\r\n    {\r\n        require(_ids.length == _amounts.length, \"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\");\r\n\r\n        // Number of transfer to execute\r\n        uint256 nTransfer = _ids.length;\r\n\r\n        // Executing all transfers\r\n        for (uint256 i = 0; i < nTransfer; i++) {\r\n            // Update storage balance of previous bin\r\n            balances[_from][_ids[i]] = balances[_from][_ids[i]]-_amounts[i];\r\n            balances[_to][_ids[i]] = balances[_to][_ids[i]]+_amounts[i];\r\n        }\r\n\r\n        // Emit event\r\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\r\n     */\r\n    function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    internal\r\n    {\r\n        // Pass data if recipient is contract\r\n        if (_to.isContract()) {\r\n            bytes4 retval = IERC1155Receiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\r\n            require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\");\r\n        }\r\n    }\r\n\r\n\r\n    /***********************************|\r\n    |         Operator Functions        |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\r\n     * @param _operator  Address to add to the set of authorized operators\r\n     * @param _approved  True if the operator is approved, false to revoke approval\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n    external override\r\n    {\r\n        // Update operator status\r\n        operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @notice Queries the approval status of an operator for a given owner\r\n     * @param _owner     The owner of the Tokens\r\n     * @param _operator  Address of authorized operator\r\n     * @return isOperator True if the operator is approved, false if not\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator)\r\n    public view virtual override returns (bool isOperator)\r\n    {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n\r\n    /***********************************|\r\n    |         Balance Functions         |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * @notice Get the balance of an account's Tokens\r\n     * @param _owner  The address of the token holder\r\n     * @param _id     ID of the Token\r\n     * @return The _owner's balance of the Token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id)\r\n    public view override returns (uint256)\r\n    {\r\n        return balances[_owner][_id];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of multiple account/token pairs\r\n     * @param _owners The addresses of the token holders\r\n     * @param _ids    ID of the Tokens\r\n     * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\r\n    public view override returns (uint256[] memory)\r\n    {\r\n        require(_owners.length == _ids.length, \"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\");\r\n\r\n        // Variables\r\n        uint256[] memory batchBalances = new uint256[](_owners.length);\r\n\r\n        // Iterate over each owner and token ID\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            batchBalances[i] = balances[_owners[i]][_ids[i]];\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n\r\n    /***********************************|\r\n    |          ERC165 Functions         |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n     */\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * INTERFACE_SIGNATURE_ERC1155 =\r\n     * bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\r\n     * bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\r\n     * bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\r\n     * bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\r\n     * bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\r\n     * bytes4(keccak256(\"isApprovedForAll(address,address)\"));\r\n     */\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param _interfaceID  The interface identifier, as specified in ERC-165\r\n     * @return `true` if the contract implements `_interfaceID` and\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external pure override returns (bool) {\r\n        if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}"
    },
    "contracts/cardlib/ERC1155Metadata.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Contract that handles metadata related methods.\r\n * @dev Methods assume a deterministic generation of URI based on token IDs.\r\n *      Methods also assume that URI uses hex representation of token IDs.\r\n */\r\ncontract ERC1155Metadata {\r\n\r\n\r\n    /***********************************|\r\n    |    Utility Internal Functions     |\r\n    |__________________________________*/\r\n\r\n    /**\r\n     * @notice Convert uint256 to string\r\n     * @param _i Unsigned integer to convert to string\r\n     */\r\n    function _uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n}\r\n\r\n"
    },
    "contracts/cardlib/ERC1155MintBurn.sol": {
      "content": "import \"./ERC1155.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\r\n *      a parent contract to be executed as they are `internal` functions\r\n */\r\ncontract ERC1155MintBurn is ERC1155 {\r\n\r\n\r\n    /****************************************|\r\n    |            Minting Functions           |\r\n    |_______________________________________*/\r\n\r\n    /**\r\n     * @notice Mint _amount of tokens of a given id\r\n     * @param _to      The address to mint tokens to\r\n     * @param _id      Token id to mint\r\n     * @param _amount  The amount to be minted\r\n     * @param _data    Data to pass if receiver is contract\r\n     */\r\n    function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    internal\r\n    {\r\n        // Add _amount\r\n        balances[_to][_id] = balances[_to][_id]+_amount;\r\n\r\n        // Emit event\r\n        emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\r\n\r\n        // Calling onReceive method if recipient is contract\r\n        _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens for each ids in _ids\r\n     * @param _to       The address to mint tokens to\r\n     * @param _ids      Array of ids to mint\r\n     * @param _amounts  Array of amount of tokens to mint per id\r\n     * @param _data    Data to pass if receiver is contract\r\n     */\r\n    function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    internal\r\n    {\r\n        require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\");\r\n\r\n        // Number of mints to execute\r\n        uint256 nMint = _ids.length;\r\n\r\n        // Executing all minting\r\n        for (uint256 i = 0; i < nMint; i++) {\r\n            // Update storage balance\r\n            balances[_to][_ids[i]] = balances[_to][_ids[i]]+(_amounts[i]);\r\n        }\r\n\r\n        // Emit batch mint event\r\n        emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\r\n\r\n        // Calling onReceive method if recipient is contract\r\n        _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\r\n    }\r\n\r\n\r\n    /****************************************|\r\n    |            Burning Functions           |\r\n    |_______________________________________*/\r\n\r\n    /**\r\n     * @notice Burn _amount of tokens of a given token id\r\n     * @param _from    The address to burn tokens from\r\n     * @param _id      Token id to burn\r\n     * @param _amount  The amount to be burned\r\n     */\r\n    function _burn(address _from, uint256 _id, uint256 _amount)\r\n    internal\r\n    {\r\n        //Substract _amount\r\n        balances[_from][_id] = balances[_from][_id]-(_amount);\r\n\r\n        // Emit event\r\n        emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\r\n     * @param _from     The address to burn tokens from\r\n     * @param _ids      Array of token ids to burn\r\n     * @param _amounts  Array of the amount to be burned\r\n     */\r\n    function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\r\n    internal\r\n    {\r\n        require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\");\r\n\r\n        // Number of mints to execute\r\n        uint256 nBurn = _ids.length;\r\n\r\n        // Executing all minting\r\n        for (uint256 i = 0; i < nBurn; i++) {\r\n            // Update storage balance\r\n            balances[_from][_ids[i]] = balances[_from][_ids[i]]-(_amounts[i]);\r\n        }\r\n\r\n        // Emit batch mint event\r\n        emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/cardlib/ERC1155Tradable.sol": {
      "content": "import \"./ERC1155.sol\";\r\nimport \"./ERC1155MintBurn.sol\";\r\nimport \"./ERC1155Metadata.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./MinterRole.sol\";\r\nimport \"./WhitelistAdminRole.sol\";\r\nimport \"./PepemonStats.sol\";\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title ERC1155Tradable\r\n * ERC1155Tradable - ERC1155 contract that whitelists an operator address,\r\n * has create and mint functionality, and supports useful standards from OpenZeppelin,\r\n  like _exists(), name(), symbol(), and totalSupply()\r\n */\r\ncontract ERC1155Tradable is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable, MinterRole, WhitelistAdminRole, PepemonStats {\r\n\r\n    uint256 private _currentTokenID = 0;\r\n    mapping(uint256 => address) public creators;\r\n    mapping(uint256 => uint256) public tokenSupply;\r\n    mapping(uint256 => uint256) public tokenMaxSupply;\r\n    // Contract name\r\n    string public name;\r\n    // Contract symbol\r\n    string public symbol;\r\n    string public baseMetadataURI;\r\n    \r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol\r\n    )  {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n    function _setBaseMetadataURI(string memory x) internal{\r\n        baseMetadataURI = x;\r\n    }\r\n    function removeWhitelistAdmin(address account) public onlyOwner {\r\n        _removeWhitelistAdmin(account);\r\n    }\r\n    \r\n    function removeMinter(address account) public onlyOwner {\r\n        _removeMinter(account);\r\n    }\r\n\r\n    function uri(uint256 _id) public view returns (string memory) {\r\n        require(_exists(_id), \"ERC1155Tradable#uri: NONEXISTENT_TOKEN\");\r\n        return _getUri(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total quantity for a token ID\r\n     * @param _id uint256 ID of the token to query\r\n     * @return amount of token in existence\r\n     */\r\n    function totalSupply(uint256 _id) public view returns (uint256) {\r\n        return tokenSupply[_id];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the max quantity for a token ID\r\n     * @param _id uint256 ID of the token to query\r\n     * @return amount of token in existence\r\n     */\r\n    function maxSupply(uint256 _id) public view returns (uint256) {\r\n        return tokenMaxSupply[_id];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Creates a new token type and assigns _initialSupply to an address\r\n     * @param _maxSupply max supply allowed\r\n     * @param _initialSupply Optional amount to supply the first owner\r\n     * @param _uri Optional URI for this token type\r\n     * @param _data Optional data to pass if receiver is contract\r\n     * @return tokenId The newly created token ID\r\n     */\r\n    function create(\r\n        uint256 _maxSupply,\r\n        uint256 _initialSupply,\r\n        string memory _uri,\r\n        bytes memory _data\r\n        \r\n    ) internal  returns (uint256 tokenId) {\r\n        require(_initialSupply <= _maxSupply, \"Initial supply cannot be more than max supply\");\r\n        uint256 _id = _getNextTokenID();\r\n        _currentTokenID++;\r\n        creators[_id] = msg.sender;\r\n\r\n        if (bytes(_uri).length > 0) {\r\n            emit URI(_uri, _id);\r\n        }\r\n\r\n        if (_initialSupply != 0) _mint(msg.sender, _id, _initialSupply, _data);\r\n        tokenSupply[_id] = _initialSupply;\r\n        tokenMaxSupply[_id] = _maxSupply;\r\n        return _id;\r\n    }\r\n    function createBattleCard(BattleCardStats calldata _stats,\r\n        uint256 _maxSupply,\r\n        uint256 _initialSupply,\r\n        string calldata _uri,\r\n        bytes calldata _data\r\n    ) external onlyWhitelistAdmin returns(uint256 tokenId){\r\n        uint _id = create(_maxSupply, _initialSupply, _uri, _data);\r\n        setBattleCardStats(_id, _stats);\r\n        return _id;\r\n    }\r\n    \r\n    function createSupportCard(SupportCardStats calldata _stats,\r\n        uint256 _maxSupply,\r\n        uint256 _initialSupply,\r\n        string calldata _uri,\r\n        bytes calldata _data\r\n    ) external onlyWhitelistAdmin returns(uint256 tokenId){\r\n        uint _id = create(_maxSupply, _initialSupply, _uri, _data);\r\n        setSupportCardStats(_id, _stats);\r\n        return _id;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints some amount of tokens to an address\r\n     * @param _to          Address of the future owner of the token\r\n     * @param _id          Token ID to mint\r\n     * @param _quantity    Amount of tokens to mint\r\n     * @param _data        Data to pass if receiver is contract\r\n     */\r\n    function mint(\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _quantity,\r\n        bytes memory _data\r\n    ) public onlyMinter {\r\n        mintPepe(_to, _id, _quantity, _data);\r\n    }\r\n    function mintPepe(\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _quantity,\r\n        bytes memory _data\r\n    ) internal{\r\n        uint256 tokenId = _id;\r\n        uint256 newSupply = tokenSupply[tokenId]+_quantity;\r\n        require(newSupply <= tokenMaxSupply[tokenId], \"Max supply reached\");\r\n        _mint(_to, _id, _quantity, _data);\r\n        tokenSupply[_id] = tokenSupply[_id]+_quantity;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists by checking to see if it has a creator\r\n     * @param _id uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 _id) internal view returns (bool) {\r\n        return creators[_id] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates the next token ID based on value of _currentTokenID\r\n     * @return uint256 for the next token ID\r\n     */\r\n    function _getNextTokenID() private view returns (uint256) {\r\n        return _currentTokenID+1;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the last minted token ID based on value of _currentTokenID\r\n     */\r\n    function getLastTokenID() public view returns (uint256) {\r\n        return _currentTokenID;\r\n    }\r\n}\r\n"
    },
    "contracts/cardlib/IERC1155.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\r\n\r\nimport \"./IERC165.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}"
    },
    "contracts/cardlib/IERC1155Receiver.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\r\n\r\nimport \"./IERC165.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}"
    },
    "contracts/cardlib/IERC165.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}"
    },
    "contracts/cardlib/MinterRole.sol": {
      "content": "import \"./Context.sol\";\r\nimport \"./Roles.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract MinterRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () {\r\n        _addMinter(_msgSender());\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        require (account != address(this));\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n"
    },
    "contracts/cardlib/Ownable.sol": {
      "content": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n\r\nimport \"./Context.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    },
    "contracts/cardlib/PepemonStats.sol": {
      "content": "import \"./WhitelistAdminRole.sol\";\r\nimport \"./Base64.sol\";\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract PepemonStats is WhitelistAdminRole{\r\n    \r\n    struct BattleCardStats {\r\n        uint16 element;\r\n        uint16 hp;\r\n        uint16 speed;\r\n        uint16 intelligence;\r\n        uint16 defense;\r\n        uint16 attack;\r\n        uint16 specialAttack;\r\n        uint16 specialDefense;\r\n        uint16 level;\r\n        string name;\r\n        string description;\r\n        string ipfsAddr;\r\n        string rarity;\r\n    }\r\n\r\n    struct SupportCardStats {\r\n        bytes32 currentRoundChanges;\r\n        bytes32 nextRoundChanges;\r\n        uint256 specialCode;\r\n        uint16 modifierNumberOfNextTurns;\r\n        bool isOffense;\r\n        bool isNormal;\r\n        bool isStackable;\r\n        string name;\r\n        string description;\r\n        string ipfsAddr;\r\n        string rarity;\r\n    }\r\n    \r\n    struct elementWR{\r\n        uint16 weakness;\r\n        uint16 resistance;\r\n    }\r\n\r\n    mapping(uint => BattleCardStats) public battleCardStats;\r\n    mapping(uint => SupportCardStats) public supportCardStats;\r\n    mapping (uint16 => string) public elementDecode;\r\n    mapping (uint16 => elementWR) public weakResist;\r\n    \r\n    constructor(){\r\n        elementDecode[1]=\"Fire\";\r\n        elementDecode[2]=\"Grass\";\r\n        elementDecode[3]=\"Water\";\r\n        elementDecode[4]=\"Lighting\";\r\n        elementDecode[5]=\"Wind\";\r\n        elementDecode[6]=\"Poison\";\r\n        elementDecode[7]=\"Ghost\";\r\n        elementDecode[8]=\"Fairy\";\r\n        elementDecode[9]=\"Earth\";\r\n        elementDecode[10]=\"Unknown\";\r\n        weakResist[1] = elementWR(3,2);\r\n        weakResist[2] = elementWR(1,3);\r\n        weakResist[3] = elementWR(4,1);\r\n        weakResist[4] = elementWR(9,5);\r\n        weakResist[5] = elementWR(6,9);\r\n        weakResist[6] = elementWR(8,2);\r\n        weakResist[7] = elementWR(8,6);\r\n        weakResist[8] = elementWR(7,8);\r\n        weakResist[9] = elementWR(2,7);\r\n        weakResist[10] = elementWR(0,0);\r\n    }\r\n    \r\n    function setBattleCardStats(uint id, BattleCardStats calldata x) public onlyWhitelistAdmin{\r\n        battleCardStats[id] = x;\r\n    }\r\n    function setSupportCardStats(uint id, SupportCardStats calldata x) public onlyWhitelistAdmin{\r\n        supportCardStats[id] = x;\r\n    }\r\n    function setWeakResist(uint16 element, elementWR calldata x) public onlyWhitelistAdmin{\r\n        weakResist[element] = x;\r\n    }\r\n    function setElementDecode(uint16 element, string calldata x) public onlyWhitelistAdmin{\r\n        elementDecode[element] = x;\r\n    }\r\n\r\n    function batchGetBattleCardStats(uint minId, uint maxId) public view returns (BattleCardStats[] memory) {\r\n        require(minId <= maxId);\r\n        BattleCardStats[] memory results = new BattleCardStats[](maxId - minId + 1);\r\n\r\n        for (uint256 i = minId; i <= maxId; i++) {\r\n            results[i - minId] = battleCardStats[i];\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    function batchGetSupportCardStats(uint minId, uint maxId) public view returns (SupportCardStats[] memory) {\r\n        require(minId <= maxId);\r\n        SupportCardStats[] memory results = new SupportCardStats[](maxId - minId + 1);\r\n\r\n        for (uint256 i = minId; i <= maxId; i++) {\r\n            results[i - minId] = supportCardStats[i];\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    //Pos 0-7 = hp, spd, int, def, atk, sp atk, sp def\r\n    //Pos 8-13 = same but for opponent\r\n    function deconvert(bytes32 num) public pure returns(int16[14] memory){\r\n        int16[14] memory arr;\r\n        for (uint i =0 ; i < 14; i++){\r\n            arr[i] = int16(uint16(bytes2(num << 240))); \r\n            num = num >> 16;\r\n        } \r\n        return arr;\r\n    }\r\n    function uint2str(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    \r\n    function convert(int16[14] calldata arr) public pure returns (bytes32){\r\n        bytes32 num;\r\n        for (uint i = 0 ; i < 14; i++ ){\r\n            num |= (bytes32(uint256(uint16(arr[i])))<<(16*i));\r\n        }\r\n        return num;\r\n    }\r\n    \r\n    //spaghetti code ahead :(\r\n        \r\n    function getSupportType(SupportCardStats memory s) internal pure returns(string memory){\r\n        string memory  x =\"Defense \";\r\n        string memory  y=\"(Special)\";\r\n        if (s.isOffense){\r\n            x = \"Offense \";\r\n        }\r\n        if (s.isNormal){\r\n            y = \"(Normal)\";\r\n        }\r\n        return string(abi.encodePacked(x, y));\r\n    }\r\n    function _URIForSupport(uint id) internal view returns (bytes memory){\r\n        SupportCardStats memory s = supportCardStats[id];\r\n        return abi.encodePacked(\r\n        \"{\\\"pool\\\": {\\\"name\\\": \\\"root\\\",\\\"points\\\": 1},\\\"external_url\\\": \\\"https://pepemon.world/\\\",\\\"image\\\": \\\"\", \r\n        s.ipfsAddr, \r\n        \"\\\",\\\"name\\\": \\\"\",\r\n        s.name, \r\n        \"\\\",\\\"description\\\": \\\"\",\r\n        s.description,\r\n        \"\\\",\\\"attributes\\\": [{\\\"trait_type\\\": \\\"Set\\\",\\\"value\\\": \\\"Pepemon Support\\\"},{\\\"trait_type\\\": \\\"Rarity\\\",\\\"value\\\": \\\"\",\r\n        s.rarity, \r\n        \"\\\"},{\\\"trait_type\\\": \\\"Type\\\",\\\"value\\\": \\\"\", \r\n        getSupportType(s), \r\n        \"\\\"}]}\");\r\n    }\r\n\r\n\r\n    function _URIForBattle(uint id) internal view returns (bytes memory){\r\n        BattleCardStats memory b = battleCardStats[id];\r\n        uint16 e = b.element;\r\n        return abi.encodePacked(\"{\\\"pool\\\": {\\\"name\\\": \\\"root\\\",\\\"points\\\": 1},\\\"external_url\\\": \\\"https://pepemon.world/\\\",\\\"image\\\": \\\"\",\r\n        b.ipfsAddr, \r\n        \"\\\",\\\"name\\\": \\\"\", \r\n        b.name, \r\n        \"\\\",\\\"description\\\": \\\"\", \r\n        b.description, \r\n        \"\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Set\\\",\\\"value\\\":\\\"Pepemon Battle\\\"},{\\\"trait_type\\\":\\\"Level\\\",\\\"value\\\":\", \r\n        uint2str(b.level),\r\n        \"},{\\\"trait_type\\\":\\\"Element\\\",\\\"value\\\":\\\"\", \r\n        elementDecode[e], \r\n         \"\\\"},{\\\"trait_type\\\":\\\"Weakness\\\",\\\"value\\\":\\\"\");\r\n    }\r\n    function _URIForBattle3(uint id) internal view returns (bytes memory){\r\n        BattleCardStats memory b = battleCardStats[id];\r\n        uint16 e = b.element;\r\n        return abi.encodePacked(\r\n            elementDecode[weakResist[e].weakness], \r\n            \"\\\"},{\\\"trait_type\\\":\\\"Resistance\\\",\\\"value\\\":\\\"\",\r\n            elementDecode[weakResist[e].resistance], \r\n            \"\\\"},{\\\"trait_type\\\":\\\"HP\\\",\\\"value\\\":\", \r\n            uint2str(b.hp));\r\n    }\r\n    function _URIForBattle2(uint id) internal view returns (bytes memory){\r\n        BattleCardStats memory b = battleCardStats[id];\r\n        return abi.encodePacked(\"},{\\\"trait_type\\\":\\\"Speed\\\",\\\"value\\\":\"\r\n        , uint2str(b.speed)\r\n        , \"},{\\\"trait_type\\\":\\\"Intelligence\\\",\\\"value\\\":\"\r\n        , uint2str(b.intelligence)\r\n        , \"},{\\\"trait_type\\\":\\\"Defense\\\",\\\"value\\\":\"\r\n        , uint2str(b.defense));\r\n    }\r\n    function _URIForBattle4(uint id) internal view returns (bytes memory){\r\n        BattleCardStats memory b = battleCardStats[id];\r\n        return abi.encodePacked(\"},{\\\"trait_type\\\":\\\"Attack\\\",\\\"value\\\":\",\r\n        uint2str(b.attack),\r\n        \"},{\\\"trait_type\\\":\\\"Special Attack\\\",\\\"value\\\":\", \r\n        uint2str(b.specialAttack), \r\n        \"},{\\\"trait_type\\\":\\\"Special Defense\\\",\\\"value\\\":\", \r\n        uint2str(b.specialDefense), \r\n        \"}]}\");\r\n    }\r\n    \r\n    function _getUri2(uint id) internal view returns(bytes memory){\r\n        if (battleCardStats[id].hp==0){\r\n            return _URIForSupport(id);\r\n        }else{\r\n            return abi.encodePacked(_URIForBattle(id), _URIForBattle3(id), _URIForBattle2(id), _URIForBattle4(id));\r\n        }\r\n    }\r\n    function _getUri(uint id) internal view returns (string memory){\r\n        return string(abi.encodePacked(\"data:application/json;base64\\r\\n\\r\\n\", Base64.encode(_getUri2(id))));\r\n    }\r\n    \r\n}\r\n"
    },
    "contracts/cardlib/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        \r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}"
    },
    "contracts/cardlib/WhitelistAdminRole.sol": {
      "content": "import \"./Context.sol\";\r\nimport \"./Roles.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor ()  {\r\n        _addWhitelistAdmin(_msgSender());\r\n        _addWhitelistAdmin(address(0x104E989923417D765215B48e03baa4aF222f3F6D));\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        require (account != address(this));\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n"
    },
    "contracts/PepemonFactory.sol": {
      "content": "import \"./cardlib/ERC1155Tradable.sol\";\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Pepemon Factory\r\n * PEPEMON - gotta farm em all\r\n */\r\ncontract PepemonFactory is ERC1155Tradable {\r\n    string private _contractURI;\r\n\r\n    constructor() ERC1155Tradable(\"PepemonBattleFactory\", \"PEPEBATTLE\") {\r\n        _setBaseMetadataURI(\"https://pepemon.finance/api/cards/\");\r\n        _contractURI = \"https://pepemon.finance/api/pepemon-erc1155\";\r\n    }\r\n\r\n    function setBaseMetadataURI(string memory newURI) public onlyWhitelistAdmin {\r\n        _setBaseMetadataURI(newURI);\r\n    }\r\n\r\n    function setContractURI(string memory newURI) public onlyWhitelistAdmin {\r\n        _contractURI = newURI;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Ends minting of token\r\n     * @param _id          Token ID for which minting will end\r\n     */\r\n    function endMinting(uint256 _id) external onlyWhitelistAdmin {\r\n        tokenMaxSupply[_id] = tokenSupply[_id];\r\n    }\r\n\r\n    function burn(\r\n        address _account,\r\n        uint256 _id,\r\n        uint256 _amount\r\n    ) public onlyMinter {\r\n        require(balanceOf(_account, _id) >= _amount, \"Cannot burn more than addres has\");\r\n        _burn(_account, _id, _amount);\r\n    }\r\n\r\n    /**\r\n     * Mint NFT and send those to the list of given addresses\r\n     */\r\n    function airdrop(uint256 _id, address[] memory _addresses) public onlyMinter {\r\n        require(tokenMaxSupply[_id] - tokenSupply[_id] >= _addresses.length, \"Cant mint above max supply\");\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            mint(_addresses[i], _id, 1, \"\");\r\n        }\r\n    }\r\n\r\n    function batchMint(\r\n        uint256 start,\r\n        uint256 end,\r\n        address to\r\n    ) external onlyMinter {\r\n        for (uint256 i = start; i <= end; i++) {\r\n            mintPepe(to, i, 1, hex\"\");\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}