{
  "address": "0xC8A27e449f2e87B770f442A423B7591006847b3F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "defaultRanking",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "battleAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "deckAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "rewardPoolAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AdminAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AdminRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "loser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "battleId",
          "type": "uint256"
        }
      ],
      "name": "BattleFinished",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "addAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "addPveDeck",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "deckOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "enter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "enterPve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "exit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "forceExit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "winnerRating",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "loserRating",
          "type": "uint256"
        }
      ],
      "name": "getEloRatingChange",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        }
      ],
      "name": "getPlayersRankings",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "rankings",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getWaitingCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "isAdmin",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isPveMode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "leaderboardPlayers",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "leaderboardPlayersCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "playerRanking",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        }
      ],
      "name": "removePveDeck",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "allow",
          "type": "bool"
        }
      ],
      "name": "setAllowBattleAgainstOneself",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "battleContractAddress",
          "type": "address"
        }
      ],
      "name": "setBattleContractAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "deckContractAddress",
          "type": "address"
        }
      ],
      "name": "setDeckContractAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "kFactor",
          "type": "uint256"
        }
      ],
      "name": "setKFactor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "matchRange",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "matchRangePerMinute",
          "type": "uint256"
        }
      ],
      "name": "setMatchRange",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "enable",
          "type": "bool"
        }
      ],
      "name": "setPveMode",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "rewardPoolAddress",
          "type": "address"
        }
      ],
      "name": "setRewardPoolAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "waitingDecks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "deckId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "enterTimestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x129d470b33a5d7cf4348d2a755687894d79d83c4a7afa6bb0d1fffa4d231f83f",
  "receipt": {
    "to": null,
    "from": "0xE9600B3025C1291F2aA211a71bC41B6bfb82bFdD",
    "contractAddress": "0xC8A27e449f2e87B770f442A423B7591006847b3F",
    "transactionIndex": 0,
    "gasUsed": "2611488",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000100800000000000010000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000",
    "blockHash": "0x00005f6c000008f6f85b86c0ea12937e3babf3a0262704e44b5ddd63fed6192c",
    "transactionHash": "0x129d470b33a5d7cf4348d2a755687894d79d83c4a7afa6bb0d1fffa4d231f83f",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 24178570,
        "transactionHash": "0x129d470b33a5d7cf4348d2a755687894d79d83c4a7afa6bb0d1fffa4d231f83f",
        "address": "0xC8A27e449f2e87B770f442A423B7591006847b3F",
        "topics": [
          "0x44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e339",
          "0x000000000000000000000000e9600b3025c1291f2aa211a71bc41b6bfb82bfdd"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x00005f6c000008f6f85b86c0ea12937e3babf3a0262704e44b5ddd63fed6192c"
      }
    ],
    "blockNumber": 24178570,
    "cumulativeGasUsed": "2611488",
    "status": 1,
    "byzantium": true
  },
  "args": [
    2000,
    "0xA1E3aeE45Aa74349cD9A1eC290A41F218Ff34EaD",
    "0x12EaA00470d8160DC43C11c32fD8c30E5fca0C05",
    "0x656c2E46D10cf128DfC22AA6F05C0E1953B2388D"
  ],
  "numDeployments": 1,
  "solcInputHash": "b9b93199ea8619af6479b4e254f0afc6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"defaultRanking\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"battleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deckAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardPoolAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"name\":\"BattleFinished\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"addPveDeck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deckOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"enterPve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"forceExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"winnerRating\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loserRating\",\"type\":\"uint256\"}],\"name\":\"getEloRatingChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"getPlayersRankings\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rankings\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPveMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leaderboardPlayers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderboardPlayersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"}],\"name\":\"removePveDeck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setAllowBattleAgainstOneself\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"battleContractAddress\",\"type\":\"address\"}],\"name\":\"setBattleContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deckContractAddress\",\"type\":\"address\"}],\"name\":\"setDeckContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"kFactor\",\"type\":\"uint256\"}],\"name\":\"setKFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"matchRange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matchRangePerMinute\",\"type\":\"uint256\"}],\"name\":\"setMatchRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setPveMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardPoolAddress\",\"type\":\"address\"}],\"name\":\"setRewardPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"waitingDecks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deckId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"enterTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"enter(uint256)\":{\"details\":\"This function cannot be used if _pveMode is set to true, players should join using \\\"enterPve\\\" instead.\",\"params\":{\"deckId\":\"The Deck of who called this function\"}},\"enterPve(uint256)\":{\"details\":\"This function cannot be used if _pveMode is set to false. In that case, players should join using \\\"enter\\\" instead, which  allows them to fight each other.\",\"params\":{\"deckId\":\"The Deck of who called this function\"}},\"exit(uint256)\":{\"params\":{\"deckId\":\"The Deck of the owner\"}},\"getEloRatingChange(uint256,uint256)\":{\"details\":\"The returned number has 2 decimals of precision, so 1501 = 15.01 Elo change\"},\"getPlayersRankings(uint256,uint256)\":{\"details\":\"Returns the rankings and addresses of players on the leaderboard, within a given range of indices.Requires that `count` is less than or equal to the number of players on the leaderboard minus `offset`, and that `offset` is less than the number of players on the leaderboard.\",\"params\":{\"count\":\"The number of rankings to return.\",\"offset\":\"The index of the first ranking to return.\"},\"returns\":{\"addresses\":\"An array of player addresses corresponding to the returned rankings.\",\"rankings\":\"An array of ranking values for the returned players.\"}},\"leaderboardPlayersCount()\":{\"details\":\"Returns the number of players currently on the leaderboard.\",\"returns\":{\"_0\":\"The number of players currently on the leaderboard.\"}},\"onERC721Received(address,address,uint256,bytes)\":{\"details\":\"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`.\"},\"setKFactor(uint256)\":{\"details\":\"Dictates the rate of change, has a direct influence on how much a player wins/loses in the ranking\",\"params\":{\"kFactor\":\"Value used to calculate the rate of change in getEloRatingChange\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"enter(uint256)\":{\"notice\":\"Tries to initiate a battle using a specified deck. If no opponents are found, the deck is placed in a wait list.\"},\"enterPve(uint256)\":{\"notice\":\"Tries to initiate a battle using a specified deck. Opponents are not other players but a set of decks added by admins.\"},\"exit(uint256)\":{\"notice\":\"Transfers a deck back to its owner and removes from the wait list\"},\"getEloRatingChange(uint256,uint256)\":{\"notice\":\"Calculates the Elo change based on the winner's and loser's ratings.\"},\"getWaitingCount()\":{\"notice\":\"Retrieves the number of waiting decks\"},\"isPveMode()\":{\"notice\":\"Tells whether or not this contract is operating in PvE mode. When in PvE mode, players cannot fight against each other (because PvE is the opposite of PvP).\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PepemonMatchmaker.sol\":\"PepemonMatchmaker\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(\\n    bytes32 requestId,\\n    uint256 randomness\\n  )\\n    internal\\n    virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(\\n    bytes32 _keyHash,\\n    uint256 _fee\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface immutable internal LINK;\\n  address immutable private vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(\\n    address _vrfCoordinator,\\n    address _link\\n  ) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(\\n    bytes32 requestId,\\n    uint256 randomness\\n  )\\n    external\\n  {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\",\"keccak256\":\"0x991e49ee47043d6667887d7ed6ab5a0f8e4e5550f92b09b0d75c1fb1a473cd8d\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256\\n    )\\n  {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(\\n    bytes32 _keyHash,\\n    uint256 _vRFInputSeed\\n  )\\n    internal\\n    pure\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\",\"keccak256\":\"0x7c8dad07e6c6c9269d97fd1191ccf9c0f0068683f1f88003e688eef9373de0d9\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 remaining\\n    );\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function balanceOf(\\n    address owner\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 balance\\n    );\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8 decimalPlaces\\n    );\\n\\n  function decreaseApproval(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function increaseApproval(\\n    address spender,\\n    uint256 subtractedValue\\n  ) external;\\n\\n  function name()\\n    external\\n    view\\n    returns (\\n      string memory tokenName\\n    );\\n\\n  function symbol()\\n    external\\n    view\\n    returns (\\n      string memory tokenSymbol\\n    );\\n\\n  function totalSupply()\\n    external\\n    view\\n    returns (\\n      uint256 totalTokensIssued\\n    );\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\",\"keccak256\":\"0x50528c237386c55ff122d047f91b32be7abe24e9dfdc609de21cd605aae83b9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\",\"keccak256\":\"0xc7aa8a96aaeb7e1672a3d5fd37582136ff46b6a6cafabcc40ec0e00a42915e1c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x2ccdc162657b677334eb08a60bb50a0dd74b22eff7150abb06487f58dbebd5e5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0xfb1161632a10d0bd366c80db583246fa490183b45ec4f59acb43b97d1a7437b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"./extensions/IERC721Enumerable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n            || interfaceId == type(IERC721Metadata).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n            : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\",\"keccak256\":\"0x8d1cabca557cb77d97d801d674f0dacc33659e1430cdd34f91ae5d033fc3d93f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0xc1c941ad1e580b4623007305921efe2f26fc7320a4edc226234dd707c658a428\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x96877bb2eb8ca360e949ee1bd77b47a14e92e42f79897c350f088f87a3c231d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xccb7e6475afcb1c5cb13b3fbf1329c10b93620a9b66393388066683915271a78\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xb8d11e77eb1ed34a33720edb551d7d6a6b0eee2bfaa40a7024020e1fdf879b16\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers.\\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0xd260defa45bc1bbdf5e6d74298fb2705bf058c3d2beb17fb1158fa1a430c5024\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x069b2631bb5b5193a58ccf7a06266c7361bd2c20095667af4402817605627f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x456e9b3a2bfe189b5249857f624f4139e59331db518483b456c4e587a20552e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x5718c5df9bd67ac68a796961df938821bb5dc0cd4c6118d77e9145afb187409b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2526b7c6a366fc211bbc176078ab02b83833e7682abcc5b3bed9d700b34e2a3e\",\"license\":\"MIT\"},\"contracts/PepemonBattle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\nimport \\\"./lib/AdminRole.sol\\\";\\r\\nimport \\\"./PepemonCardDeck.sol\\\";\\r\\nimport \\\"./iface/IPepemonCardOracle.sol\\\";\\r\\nimport \\\"./lib/ChainLinkRngOracle.sol\\\";\\r\\n\\r\\ncontract PepemonBattle is AdminRole {\\r\\n\\r\\n    event BattleCreated(\\r\\n        address indexed player1Addr,\\r\\n        address indexed player2Addr,\\r\\n        uint256 battleId,\\r\\n        uint256 p1DeckId,\\r\\n        uint256 p2DeckId\\r\\n    );\\r\\n\\r\\n    mapping (uint => uint) public battleIdRNGSeed;\\r\\n\\r\\n    uint constant _max_inte = 8;\\r\\n    uint constant _max_cards_on_table = 5;\\r\\n    uint constant _refreshTurn = 5;\\r\\n\\r\\n    //Attacker can either be PLAYER_ONE or PLAYER_TWO\\r\\n    enum Attacker {\\r\\n        PLAYER_ONE,\\r\\n        PLAYER_TWO\\r\\n    }\\r\\n\\r\\n    //Game can either be in FIRST_HALF or SECOND_HALF\\r\\n    enum TurnHalves {\\r\\n        FIRST_HALF,\\r\\n        SECOND_HALF\\r\\n    }\\r\\n\\r\\n    //Battle contains:\\r\\n    //battleId = ID of this battle\\r\\n    //player1, player2 = players\\r\\n    //currentTurn\\r\\n    //attacker\\r\\n    //turnHalves => first half or second half?\\r\\n    struct Battle {\\r\\n        uint256 battleId;\\r\\n        Player player1;\\r\\n        Player player2;\\r\\n        uint256 currentTurn;\\r\\n        Attacker attacker;\\r\\n        TurnHalves turnHalves;\\r\\n    }\\r\\n\\r\\n    // Used to keep a local copy of players battle/support cards instead of reloading\\r\\n    // from the oracle\\r\\n    struct PlayersCards {\\r\\n        uint256 player1SupportCardsCount;\\r\\n        uint256 player2SupportCardsCount;\\r\\n        IPepemonCardOracle.BattleCardStats player1Battlecard;\\r\\n        IPepemonCardOracle.BattleCardStats player2Battlecard;\\r\\n        uint256[] player1SupportCards;\\r\\n        uint256[] player2SupportCards;\\r\\n    }\\r\\n\\r\\n    //playerAddr\\r\\n    //deckId = Id of deck\\r\\n    //hand = keeps track of current player's stats (such as health)\\r\\n    //totalSupportCardIds = all IDs of support cards\\r\\n    //playedCardCount = number of cards played already\\r\\n    struct Player {\\r\\n        address playerAddr;\\r\\n        uint256 deckId;\\r\\n        Hand hand;\\r\\n        uint256[60] totalSupportCardIds;\\r\\n        uint256 playedCardCount;\\r\\n    }\\r\\n\\r\\n    //health - health of player's battle card\\r\\n    // battleCardId = card id of player\\r\\n    // currentBCstats = all stats of the player's battle cards currently\\r\\n    // supportCardInHandIds = IDs of the support cards in your current hand\\r\\n    //                  the amount of support cards a player can play is determined by intelligence\\r\\n    // tableSupportCardStats = Number of support cards that are currently played on the table\\r\\n    // currentSuportCards = cards on the table, based on which turn ago they were played\\r\\n    //                      Notice that the number of turns is limited by _refreshTurn\\r\\n    struct Hand {\\r\\n        int256 health;\\r\\n        uint256 battleCardId;\\r\\n        CurrentBattleCardStats currentBCstats;\\r\\n        uint256[_max_inte] supportCardInHandIds;\\r\\n        uint256 tableSupportCardStats;\\r\\n        TableSupportCardStats[_max_cards_on_table] tableSupportCards;\\r\\n    }\\r\\n    //spd, inte, def, atk, sAtk, sDef - Current stats of battle card (with powerups included)\\r\\n    //Each param can go into the negatives\\r\\n    struct CurrentBattleCardStats {\\r\\n        int256 spd;\\r\\n        uint256 inte;\\r\\n        int256 def;\\r\\n        int256 atk;\\r\\n        int256 sAtk;\\r\\n        int256 sDef;\\r\\n    }\\r\\n\\r\\n    //links supportCardID with effectMany\\r\\n    struct TableSupportCardStats {\\r\\n        uint256 supportCardId;\\r\\n        IPepemonCardOracle.EffectMany effectMany;\\r\\n    }\\r\\n\\r\\n    uint256 private _nextBattleId;\\r\\n\\r\\n    bool private _allowBattleAgainstOneself;\\r\\n\\r\\n    IPepemonCardOracle private _cardContract;\\r\\n    PepemonCardDeck private _deckContract;\\r\\n    ChainLinkRngOracle private _randNrGenContract;\\r\\n\\r\\n    constructor(\\r\\n        address cardOracleAddress,\\r\\n        address deckOracleAddress,\\r\\n        address randOracleAddress\\r\\n    ) {\\r\\n        _cardContract = IPepemonCardOracle(cardOracleAddress);\\r\\n        _deckContract = PepemonCardDeck(deckOracleAddress);\\r\\n        _randNrGenContract = ChainLinkRngOracle(randOracleAddress);\\r\\n        _nextBattleId = 1;\\r\\n        _allowBattleAgainstOneself = false;\\r\\n    }\\r\\n\\r\\n    function setCardContractAddress(address cardOracleAddress) public onlyAdmin {\\r\\n        _cardContract = IPepemonCardOracle(cardOracleAddress);\\r\\n    }\\r\\n\\r\\n    function setBattleContractAddress(address deckOracleAddress) public onlyAdmin {\\r\\n        _deckContract = PepemonCardDeck(deckOracleAddress);\\r\\n    }\\r\\n\\r\\n    function setRandNrGenContractAddress(address randOracleAddress) public onlyAdmin {\\r\\n        _randNrGenContract = ChainLinkRngOracle(randOracleAddress);\\r\\n    }\\r\\n\\r\\n    function setAllowBattleAgainstOneself(bool allow) public onlyAdmin {\\r\\n        _allowBattleAgainstOneself = allow;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Create battle\\r\\n     * @param p1Addr address player1\\r\\n     * @param p1DeckId uint256\\r\\n     * @param p2Addr address player2\\r\\n     * @param p2DeckId uint256\\r\\n     */\\r\\n    function createBattle(\\r\\n        address p1Addr,\\r\\n        uint256 p1DeckId,\\r\\n        address p2Addr,\\r\\n        uint256 p2DeckId\\r\\n    ) public onlyAdmin returns (Battle memory, uint256 battleId)  {\\r\\n        require(_allowBattleAgainstOneself || p1Addr != p2Addr, \\\"PepemonBattle: Cannot battle yourself\\\");\\r\\n\\r\\n        (uint256 p1BattleCardId, ) = _deckContract.decks(p1DeckId);\\r\\n        (uint256 p2BattleCardId, ) = _deckContract.decks(p2DeckId);\\r\\n\\r\\n        IPepemonCardOracle.BattleCardStats memory p1BattleCard = _cardContract.getBattleCardById(p1BattleCardId);\\r\\n        IPepemonCardOracle.BattleCardStats memory p2BattleCard = _cardContract.getBattleCardById(p2BattleCardId);\\r\\n\\r\\n        Battle memory newBattle;\\r\\n        // Initiate battle ID\\r\\n        newBattle.battleId = _nextBattleId;\\r\\n        // Initiate player1\\r\\n        newBattle.player1.hand.health = int256(uint256(p1BattleCard.hp));\\r\\n        newBattle.player1.hand.battleCardId = p1BattleCardId;\\r\\n        newBattle.player1.playerAddr = p1Addr;\\r\\n        newBattle.player1.deckId = p1DeckId;\\r\\n        // Initiate player2\\r\\n        newBattle.player2.hand.health = int256(uint256(p2BattleCard.hp));\\r\\n        newBattle.player2.hand.battleCardId = p2BattleCardId;\\r\\n        newBattle.player2.playerAddr = p2Addr;\\r\\n        newBattle.player2.deckId = p2DeckId;\\r\\n        // Set the RNG seed\\r\\n        battleIdRNGSeed[_nextBattleId] = _randSeed(newBattle);\\r\\n\\r\\n        //Emit event\\r\\n        emit BattleCreated(p1Addr, p2Addr, _nextBattleId, p1DeckId, p2DeckId);\\r\\n        return (newBattle, _nextBattleId++);\\r\\n    }\\r\\n\\r\\n    function getPlayersCards(\\r\\n        uint256 player1BattleCardId,\\r\\n        uint256 player2BattleCardId,\\r\\n        uint256 player1DeckId,\\r\\n        uint256 player2DeckId\\r\\n    ) internal view returns (PlayersCards memory) {\\r\\n        // Get Battle Cards for Player 1 and Player 2\\r\\n        IPepemonCardOracle.BattleCardStats memory player1Battlecard = _cardContract.getBattleCardById(player1BattleCardId);\\r\\n        IPepemonCardOracle.BattleCardStats memory player2Battlecard = _cardContract.getBattleCardById(player2BattleCardId);\\r\\n\\r\\n        // Get Support Cards for Player 1 and Player 2\\r\\n        uint256[] memory player1SupportCards = _deckContract.getAllSupportCardsInDeck(player1DeckId);\\r\\n        uint256[] memory player2SupportCards = _deckContract.getAllSupportCardsInDeck(player2DeckId);\\r\\n\\r\\n        // Get Support Card count for Player 1 and Player 2\\r\\n        uint256 player1SupportCardsCount = _deckContract.getSupportCardCountInDeck(player1DeckId);\\r\\n        uint256 player2SupportCardsCount = _deckContract.getSupportCardCountInDeck(player2DeckId);\\r\\n\\r\\n        // Create and return the PlayersCards struct instance\\r\\n        return PlayersCards({\\r\\n            player1Battlecard: player1Battlecard,\\r\\n            player1SupportCards: player1SupportCards,\\r\\n            player1SupportCardsCount: player1SupportCardsCount,\\r\\n            player2Battlecard: player2Battlecard,\\r\\n            player2SupportCards: player2SupportCards,\\r\\n            player2SupportCardsCount: player2SupportCardsCount\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function goForBattle(Battle memory battle) public view returns (Battle memory, address winner) {\\r\\n        // local cache for cards and decks info to reduce gas usage\\r\\n        PlayersCards memory cards = getPlayersCards(\\r\\n            battle.player1.hand.battleCardId,\\r\\n            battle.player2.hand.battleCardId,\\r\\n            battle.player1.deckId,\\r\\n            battle.player2.deckId\\r\\n        );\\r\\n\\r\\n        //Initialize battle by starting the first turn\\r\\n        battle = goForNewTurn(battle, cards);\\r\\n        address winnerAddr;\\r\\n        // Battle goes!\\r\\n        while (true) {\\r\\n            // Resolve attacker in the current turn\\r\\n            battle = resolveAttacker(battle);\\r\\n            // Fight\\r\\n            battle = fight(battle);\\r\\n\\r\\n            // Check if battle ended\\r\\n            (bool isEnded, address win) = checkIfBattleEnded(battle);\\r\\n            if (isEnded) {\\r\\n                winnerAddr = win;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            // Resolve turn halves\\r\\n            battle = updateTurnInfo(battle, cards);\\r\\n        }\\r\\n        return (battle, winnerAddr);\\r\\n    }\\r\\n\\r\\n    //If currently in first half -> go to second half\\r\\n    //If currently in second half -> make a new turn\\r\\n    function updateTurnInfo(Battle memory battle, PlayersCards memory cards) internal view returns (Battle memory) {\\r\\n        // If the current half is first, go over second half\\r\\n        // or go over next turn\\r\\n        if (battle.turnHalves == TurnHalves.FIRST_HALF) {\\r\\n            battle.turnHalves = TurnHalves.SECOND_HALF;\\r\\n        } else {\\r\\n            battle = goForNewTurn(battle, cards);\\r\\n        }\\r\\n\\r\\n        return battle;\\r\\n    }\\r\\n\\r\\n    //Things this function does:\\r\\n    //Reset both players hand infos back to base stats (stats with no support card powerups)\\r\\n    //Check if support cards need to be scrambled and redealt\\r\\n    //Redeal support cards if necessary\\r\\n    //Calculate support card's power\\r\\n    //Finally, draw Pepemon's intelligence number of cards.\\r\\n    function goForNewTurn(Battle memory battle, PlayersCards memory cards) internal view returns (Battle memory) {\\r\\n        Player memory player1 = battle.player1;\\r\\n        Player memory player2 = battle.player2;\\r\\n\\r\\n        // Load base battle card stats (stats without any powerups)\\r\\n        // and reset both players' hand infos to base stats\\r\\n        player1.hand.currentBCstats = getCardStats(cards.player1Battlecard);\\r\\n        player2.hand.currentBCstats = getCardStats(cards.player2Battlecard);\\r\\n\\r\\n        uint256 p1SupportCardIdsLength = cards.player1SupportCardsCount;\\r\\n        uint256 p2SupportCardIdsLength = cards.player2SupportCardsCount;\\r\\n\\r\\n        //Refresh cards every 5 turns\\r\\n        bool isRefreshTurn = (battle.currentTurn % _refreshTurn == 0);\\r\\n\\r\\n        if (isRefreshTurn) {\\r\\n            //Need to refresh decks\\r\\n\\r\\n            // Shuffle player1 support cards\\r\\n            uint[] memory scrambled = Arrays.shuffle(cards.player1SupportCards, _randMod(69, battle));\\r\\n\\r\\n            //Copy back scrambled cards to original list\\r\\n            for (uint i = 0 ; i < p1SupportCardIdsLength; i++){\\r\\n                player1.totalSupportCardIds[i]=scrambled[i];\\r\\n            }\\r\\n            \\r\\n            //Reset played card count\\r\\n            player1.playedCardCount = 0;\\r\\n\\r\\n            //Shuffling player 2 support cards\\r\\n            //Create a pseudorandom seed and shuffle the cards\\r\\n            uint[] memory scrambled2 = Arrays.shuffle(cards.player2SupportCards, _randMod(420, battle));\\r\\n\\r\\n            //Copy the support cards back into the list\\r\\n            for (uint256 i = 0; i < p2SupportCardIdsLength; i++) {\\r\\n                player2.totalSupportCardIds[i]=scrambled2[i];\\r\\n            }\\r\\n            \\r\\n            //Reset player2 played card counts\\r\\n            player2.playedCardCount = 0;\\r\\n        }\\r\\n        else \\r\\n        {\\r\\n            //Don't need to refresh cards now\\r\\n\\r\\n            // Get temp support info of previous turn's hands and calculate their effect for the new turn\\r\\n            player1.hand = calSupportCardsOnTable(player1.hand, player2.hand);\\r\\n            player2.hand = calSupportCardsOnTable(player2.hand, player1.hand);\\r\\n        }\\r\\n\\r\\n        // Draw player1 support cards for the new turn\\r\\n        uint256 remainingCards = p1SupportCardIdsLength - player1.playedCardCount;\\r\\n        // limit number of cards to be taken to prevent taking invalid cards\\r\\n        player1.hand.currentBCstats.inte = remainingCards < player1.hand.currentBCstats.inte ? remainingCards : player1.hand.currentBCstats.inte;\\r\\n        for (uint256 i = 0; i < player1.hand.currentBCstats.inte; i++) {\\r\\n            // \\\"totalSupportCardIds\\\" array has 60 elements, max intelligence is 8 (_max_inte), each 5 rounds playedCardCount is reset, \\r\\n            // so in total, 40 (5*8) cards could end up being used, no out of bounds errors\\r\\n            player1.hand.supportCardInHandIds[i] = player1.totalSupportCardIds[i + player1.playedCardCount];\\r\\n        }\\r\\n        player1.playedCardCount += player1.hand.currentBCstats.inte;\\r\\n\\r\\n        // Draw player2 support cards for the new turn\\r\\n        remainingCards = p2SupportCardIdsLength - player2.playedCardCount;\\r\\n        // limit number of cards to be taken to prevent taking invalid cards\\r\\n        player2.hand.currentBCstats.inte = remainingCards < player2.hand.currentBCstats.inte ? remainingCards : player2.hand.currentBCstats.inte;\\r\\n        for (uint256 i = 0; i < player2.hand.currentBCstats.inte; i++) {\\r\\n            player2.hand.supportCardInHandIds[i] = player2.totalSupportCardIds[i + player2.playedCardCount];\\r\\n        }\\r\\n        player2.playedCardCount += player2.hand.currentBCstats.inte;\\r\\n\\r\\n        //Update current battle info\\r\\n        battle.player1 = player1;\\r\\n        battle.player2 = player2;\\r\\n\\r\\n        // Increment current turn number of battle\\r\\n        battle.currentTurn++;\\r\\n\\r\\n        // Go for first half in turn\\r\\n        battle.turnHalves = TurnHalves.FIRST_HALF;\\r\\n\\r\\n        return battle;\\r\\n    }\\r\\n\\r\\n    //This method calculates the battle card's stats after taking into consideration all the support cards currently being played\\r\\n    function calSupportCardsOnTable(Hand memory hand, Hand memory oppHand) internal pure returns (Hand memory) {\\r\\n        for (uint256 i = 0; i < hand.tableSupportCardStats; i++) {\\r\\n            //Loop through every support card currently played\\r\\n\\r\\n            //Get the support card being considered now\\r\\n            TableSupportCardStats memory tableSupportCardStat = hand.tableSupportCards[i];\\r\\n            \\r\\n            //Get the effect of that support card\\r\\n            IPepemonCardOracle.EffectMany memory effect = tableSupportCardStat.effectMany;\\r\\n            \\r\\n            //If there is at least 1 turn left\\r\\n            if (effect.numTurns >= 1) {\\r\\n\\r\\n                //If the effect is for me\\r\\n                if (effect.effectFor == IPepemonCardOracle.EffectFor.ME) {\\r\\n                    // Change my card's stats using that support card\\r\\n                    // Currently effectTo of EffectMany can be ATTACK, DEFENSE, SPEED and INTELLIGENCE\\r\\n                    //Get the statistic changed and update it \\r\\n                    //Intelligence can't go into the negatives nor above _max_inte\\r\\n                    if (effect.effectTo == IPepemonCardOracle.EffectTo.ATTACK) {\\r\\n                        hand.currentBCstats.atk += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.DEFENSE) {\\r\\n                        hand.currentBCstats.def += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.SPEED) {\\r\\n                        hand.currentBCstats.spd += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.INTELLIGENCE) {\\r\\n                        int temp;\\r\\n                        temp = int256(hand.currentBCstats.inte) + effect.power;\\r\\n                        temp = temp > int(_max_inte) ? int(_max_inte) : temp;\\r\\n                        hand.currentBCstats.inte = (temp > 0 ? uint(temp) : 0);\\r\\n                    }\\r\\n                } else {\\r\\n                    //The card affects the opp's pepemon\\r\\n                    //Update card stats of the opp's pepemon\\r\\n                    //Make sure INT stat can't go below zero nor above _max_inte\\r\\n                    if (effect.effectTo == IPepemonCardOracle.EffectTo.ATTACK) {\\r\\n                        oppHand.currentBCstats.atk += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.DEFENSE) {\\r\\n                        oppHand.currentBCstats.def += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.SPEED) {\\r\\n                        oppHand.currentBCstats.spd += effect.power;\\r\\n                    } else if (effect.effectTo == IPepemonCardOracle.EffectTo.INTELLIGENCE) {\\r\\n                        int temp;\\r\\n                        temp = int256(oppHand.currentBCstats.inte) + effect.power;\\r\\n                        temp = temp > int(_max_inte) ? int(_max_inte) : temp;\\r\\n                        oppHand.currentBCstats.inte = (temp > 0 ? uint(temp) : 0);\\r\\n                    }\\r\\n                }\\r\\n                // Decrease effect numTurns by 1 since 1 turn has already passed\\r\\n                effect.numTurns--;\\r\\n                // Delete this one from tableSupportCardStat if all turns of the card have been exhausted\\r\\n                if (effect.numTurns == 0) {\\r\\n                    if (i < hand.tableSupportCardStats - 1) {\\r\\n                        hand.tableSupportCards[i] = hand.tableSupportCards[hand.tableSupportCardStats - 1];\\r\\n                    }\\r\\n                    delete hand.tableSupportCards[hand.tableSupportCardStats - 1];\\r\\n                    hand.tableSupportCardStats--;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return hand;\\r\\n    }\\r\\n\\r\\n    //This method gets the current attacker\\r\\n    function resolveAttacker(Battle memory battle) internal view returns (Battle memory) {\\r\\n        CurrentBattleCardStats memory p1CurrentBattleCardStats = battle.player1.hand.currentBCstats;\\r\\n        CurrentBattleCardStats memory p2CurrentBattleCardStats = battle.player2.hand.currentBCstats;\\r\\n\\r\\n        if (battle.turnHalves == TurnHalves.FIRST_HALF) {\\r\\n            //Player with highest speed card goes first\\r\\n            if (p1CurrentBattleCardStats.spd > p2CurrentBattleCardStats.spd) {\\r\\n                battle.attacker = Attacker.PLAYER_ONE;\\r\\n            } else if (p1CurrentBattleCardStats.spd < p2CurrentBattleCardStats.spd) {\\r\\n                battle.attacker = Attacker.PLAYER_TWO;\\r\\n            } else {\\r\\n                //Tiebreak: intelligence\\r\\n                if (p1CurrentBattleCardStats.inte > p2CurrentBattleCardStats.inte) {\\r\\n                    battle.attacker = Attacker.PLAYER_ONE;\\r\\n                } else if (p1CurrentBattleCardStats.inte < p2CurrentBattleCardStats.inte) {\\r\\n                    battle.attacker = Attacker.PLAYER_TWO;\\r\\n                } else {\\r\\n                    //Second tiebreak: use RNG\\r\\n                    uint256 rand = _randMod(69420, battle) % 2;\\r\\n                    battle.attacker = (rand == 0 ? Attacker.PLAYER_ONE : Attacker.PLAYER_TWO);\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            //For second half, switch players\\r\\n            battle.attacker = (battle.attacker == Attacker.PLAYER_ONE ? Attacker.PLAYER_TWO : Attacker.PLAYER_ONE);\\r\\n        }\\r\\n\\r\\n        return battle;\\r\\n    }\\r\\n\\r\\n    //Create a random seed, using the chainlink number and the addresses of the combatants as entropy\\r\\n    function _randSeed(Battle memory battle) private view returns (uint256) {\\r\\n        //Get the chainlink random number\\r\\n        uint chainlinkNumber = _randNrGenContract.getRandomNumber();\\r\\n        //Create a new pseudorandom number using the seed and battle info as entropy\\r\\n        //This makes sure the RNG returns a different number every time\\r\\n        uint256 randomNumber = uint(keccak256(abi.encodePacked(block.number, chainlinkNumber, battle.player1.playerAddr, battle.player2.playerAddr)));\\r\\n        return randomNumber;\\r\\n    }\\r\\n\\r\\n    function _randMod(uint256 seed, Battle memory battle) private view returns (uint256) {\\r\\n        uint256 randomNumber = uint(keccak256(abi.encodePacked(seed, battle.currentTurn, battleIdRNGSeed[battle.battleId])));\\r\\n        return randomNumber;\\r\\n    }\\r\\n\\r\\n    //Check if battle ended by looking at player's health\\r\\n    function checkIfBattleEnded(Battle memory battle) public pure returns (bool, address) {\\r\\n        if (battle.player1.hand.health <= 0) {\\r\\n            return (true, battle.player1.playerAddr);\\r\\n        } else if (battle.player2.hand.health <= 0) {\\r\\n            return (true, battle.player2.playerAddr);\\r\\n        } else {\\r\\n            return (false, address(0));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function fight(Battle memory battle) public view returns (Battle memory) {\\r\\n        Hand memory atkHand;\\r\\n        Hand memory defHand;\\r\\n\\r\\n        //Get attacker and defender for current turn\\r\\n        if (battle.attacker == Attacker.PLAYER_ONE) {\\r\\n            atkHand = battle.player1.hand;\\r\\n            defHand = battle.player2.hand;\\r\\n        } else {\\r\\n            atkHand = battle.player2.hand;\\r\\n            defHand = battle.player1.hand;\\r\\n        }\\r\\n\\r\\n        (atkHand, defHand) = calSupportCardsInHand(atkHand, defHand);\\r\\n\\r\\n        //Give 2 point advantage if weakness, 2 point disadvantage if resistance\\r\\n        atkHand.currentBCstats.atk += resistanceWeaknessCal(atkHand, defHand);\\r\\n\\r\\n        // Fight\\r\\n\\r\\n        //Calculate HP loss for defending player\\r\\n        if (atkHand.currentBCstats.atk > defHand.currentBCstats.def) {\\r\\n            //If attacker's attack > defender's defense, find difference. That is the defending player's HP loss\\r\\n            defHand.health -= (atkHand.currentBCstats.atk - defHand.currentBCstats.def);\\r\\n        } else {\\r\\n            //Otherwise, defender loses 1 HP\\r\\n            defHand.health -= 1;\\r\\n        }\\r\\n\\r\\n        //Write updated info back into battle\\r\\n        if (battle.attacker == Attacker.PLAYER_ONE) {\\r\\n            battle.player1.hand = atkHand;\\r\\n            battle.player2.hand = defHand;\\r\\n        } else {\\r\\n            battle.player1.hand = defHand;\\r\\n            battle.player2.hand = atkHand;\\r\\n        }\\r\\n\\r\\n        return battle;\\r\\n    }\\r\\n\\r\\n    \\r\\n    //We calculate the effect of every card in the player's hand\\r\\n    function calSupportCardsInHand(Hand memory atkHand, Hand memory defHand) public view returns (Hand memory, Hand memory) {\\r\\n        // If this card is included in player's hand, adds an additional power equal to the total of\\r\\n        // all normal offense/defense cards\\r\\n        bool isPower0CardIncluded = false;\\r\\n        // Total sum of normal support cards\\r\\n        int256 totalNormalPower = 0;\\r\\n        // Cal attacker hand\\r\\n        for (uint256 i = 0; i < atkHand.currentBCstats.inte; i++) {\\r\\n            //Loop through every card the attacker has in his hand\\r\\n            uint256 id = atkHand.supportCardInHandIds[i];\\r\\n\\r\\n            //Get the support cardStats\\r\\n            IPepemonCardOracle.SupportCardStats memory cardStats = _cardContract.getSupportCardById(id);\\r\\n            if (cardStats.supportCardType == IPepemonCardOracle.SupportCardType.OFFENSE) {\\r\\n                // Card type is OFFENSE.\\r\\n                // Calc effects of EffectOne array\\r\\n\\r\\n                IPepemonCardOracle.EffectOne memory effectOne = cardStats.effectOne;\\r\\n                \\r\\n                //Checks if that support card is triggered and by how much it is triggered by\\r\\n                (bool isTriggered, uint256 multiplier) = checkReqCode(atkHand, defHand, effectOne.reqCode, true);\\r\\n                if (isTriggered) {\\r\\n                    //use triggeredPower if triggered\\r\\n                    atkHand.currentBCstats.atk += effectOne.triggeredPower * int256(multiplier);\\r\\n                    totalNormalPower += effectOne.triggeredPower * int256(multiplier);\\r\\n                }\\r\\n                else{\\r\\n                    //use basePower if not\\r\\n                    atkHand.currentBCstats.atk += effectOne.basePower;\\r\\n                    totalNormalPower += effectOne.basePower;\\r\\n                }\\r\\n\\r\\n            } else if (cardStats.supportCardType == IPepemonCardOracle.SupportCardType.STRONG_OFFENSE) {\\r\\n                // Card type is STRONG OFFENSE.\\r\\n\\r\\n                //Make sure unstackable cards can't be stacked\\r\\n                if (cardStats.unstackable) {\\r\\n                    bool isNew = true;\\r\\n                    // Check if card is new to previous cards\\r\\n                    for (uint256 j = 0; j < i; j++) {\\r\\n                        if (id == atkHand.supportCardInHandIds[j]) {\\r\\n                            isNew = false;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if (!isNew) {\\r\\n                        //If it isn't - skip card\\r\\n                        continue;\\r\\n                    }\\r\\n                    // Check if card is new to temp support info cards\\r\\n                    for (uint256 j = 0; j < atkHand.tableSupportCardStats; j++) {\\r\\n                        if (id == atkHand.tableSupportCards[j].supportCardId) {\\r\\n                            isNew = false;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if (!isNew) {\\r\\n                        //If it isn't - skip card\\r\\n                        continue;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Calc effects of EffectOne array\\r\\n\\r\\n                IPepemonCardOracle.EffectOne memory effectOne = cardStats.effectOne;\\r\\n                (bool isTriggered, uint256 multiplier) = checkReqCode(atkHand, defHand, effectOne.reqCode, true);\\r\\n                if (isTriggered) {\\r\\n                    //If triggered: use triggered power\\r\\n                    if (multiplier > 1) {\\r\\n                        atkHand.currentBCstats.atk += effectOne.triggeredPower * int256(multiplier);\\r\\n                    } else {\\r\\n                        if (effectOne.effectTo == IPepemonCardOracle.EffectTo.STRONG_ATTACK) {\\r\\n                            // If it's a use Special Attack instead of Attack card\\r\\n                            atkHand.currentBCstats.atk = atkHand.currentBCstats.sAtk;\\r\\n                            continue;\\r\\n                        } else if (effectOne.triggeredPower == 0) {\\r\\n                            // We have a card that says ATK is increased by amount\\r\\n                            // Equal to the total of all offense cards in the current turn\\r\\n                            isPower0CardIncluded = true;\\r\\n                            continue;\\r\\n                        }\\r\\n                        atkHand.currentBCstats.atk += effectOne.triggeredPower;\\r\\n                    }\\r\\n                }\\r\\n                else{\\r\\n                    //If not triggered: use base power instead\\r\\n                    atkHand.currentBCstats.atk += effectOne.basePower;\\r\\n                    totalNormalPower += effectOne.basePower;\\r\\n                }\\r\\n                // If card lasts for >1 turns\\r\\n                if (cardStats.effectMany.power != 0) {\\r\\n                    // Add card  to table if <5 on table currently\\r\\n                    if (atkHand.tableSupportCardStats < _max_cards_on_table) {\\r\\n                        atkHand.tableSupportCards[atkHand.tableSupportCardStats++] = TableSupportCardStats({\\r\\n                            supportCardId: id,\\r\\n                            effectMany: cardStats.effectMany\\r\\n                        });\\r\\n                    }\\r\\n                }\\r\\n            } else {\\r\\n                // Other card type is ignored.\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n        if (isPower0CardIncluded) {\\r\\n            //If we have a card that says ATK is increased by amount equal to total of all offense cards\\r\\n            atkHand.currentBCstats.atk += totalNormalPower;\\r\\n        }\\r\\n        // Cal defense hand\\r\\n        isPower0CardIncluded = false;\\r\\n        totalNormalPower = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < defHand.currentBCstats.inte; i++) {\\r\\n            uint256 id = defHand.supportCardInHandIds[i];\\r\\n            IPepemonCardOracle.SupportCardStats memory card = _cardContract.getSupportCardById(id);\\r\\n            if (card.supportCardType == IPepemonCardOracle.SupportCardType.DEFENSE) {\\r\\n                // Card type is DEFENSE\\r\\n                // Calc effects of EffectOne array\\r\\n\\r\\n                    IPepemonCardOracle.EffectOne memory effectOne = card.effectOne;\\r\\n                    (bool isTriggered, uint256 multiplier) = checkReqCode(atkHand, defHand, effectOne.reqCode, false);\\r\\n                    if (isTriggered) {\\r\\n                        defHand.currentBCstats.def += effectOne.triggeredPower * int256(multiplier);\\r\\n                        totalNormalPower += effectOne.triggeredPower * int256(multiplier);\\r\\n                    }\\r\\n                    else{\\r\\n                        //If not triggered, use base power instead\\r\\n                        defHand.currentBCstats.def += effectOne.basePower;\\r\\n                        totalNormalPower += effectOne.basePower;\\r\\n                    }\\r\\n\\r\\n            } else if (card.supportCardType == IPepemonCardOracle.SupportCardType.STRONG_DEFENSE) {\\r\\n                // Card type is STRONG DEFENSE\\r\\n                if (card.unstackable) {\\r\\n                    bool isNew = true;\\r\\n                    // Check if card is new to previous cards\\r\\n                    for (uint256 j = 0; j < i; j++) {\\r\\n                        if (id == defHand.supportCardInHandIds[j]) {\\r\\n                            isNew = false;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    // Check if card is new to temp support info cards\\r\\n                    for (uint256 j = 0; j < defHand.tableSupportCardStats; j++) {\\r\\n                        if (id == defHand.tableSupportCards[j].supportCardId) {\\r\\n                            isNew = false;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if (!isNew) {\\r\\n                        continue;\\r\\n                    }\\r\\n                }\\r\\n                // Calc effects of EffectOne array\\r\\n                IPepemonCardOracle.EffectOne memory effectOne = card.effectOne;\\r\\n                (bool isTriggered, uint256 num) = checkReqCode(atkHand, defHand, effectOne.reqCode, false);\\r\\n                if (isTriggered) {\\r\\n                    if (num > 0) {\\r\\n                        defHand.currentBCstats.def += effectOne.triggeredPower * int256(num);\\r\\n                    } else {\\r\\n                        if (effectOne.effectTo == IPepemonCardOracle.EffectTo.STRONG_DEFENSE) {\\r\\n                            defHand.currentBCstats.def = defHand.currentBCstats.sDef;\\r\\n                            continue;\\r\\n                        } else if (effectOne.triggeredPower == 0) {\\r\\n                            // Equal to the total of all defense cards in the current turn\\r\\n                            isPower0CardIncluded = true;\\r\\n                            continue;\\r\\n                        }\\r\\n                        defHand.currentBCstats.def += effectOne.triggeredPower;\\r\\n                    }\\r\\n                }\\r\\n                else{\\r\\n                    //If not triggered, use base stats instead\\r\\n                    defHand.currentBCstats.def += effectOne.basePower;\\r\\n                    totalNormalPower += effectOne.basePower;\\r\\n                }\\r\\n            \\r\\n                // If card effect lasts >1 turn\\r\\n                if (card.effectMany.power != 0) {\\r\\n                    // Add card to table if there are <5 cards on table right now\\r\\n                    if (defHand.tableSupportCardStats < _max_cards_on_table) {\\r\\n                        defHand.tableSupportCards[defHand.tableSupportCardStats++] = TableSupportCardStats({\\r\\n                            supportCardId: id,\\r\\n                            effectMany: card.effectMany\\r\\n                        });\\r\\n                    }\\r\\n                }\\r\\n            } else {\\r\\n                // Other card type is ignored.\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n        if (isPower0CardIncluded) {\\r\\n            //If a \\\"add total of defense\\\" card is included\\r\\n            defHand.currentBCstats.def += totalNormalPower;\\r\\n        }\\r\\n\\r\\n        return (atkHand, defHand);\\r\\n    }\\r\\n\\r\\n    //Strip important game information (like speed, intelligence, etc.) from battle card\\r\\n    function getCardStats(IPepemonCardOracle.BattleCardStats memory x) internal pure returns (CurrentBattleCardStats memory){\\r\\n        CurrentBattleCardStats memory ret;\\r\\n\\r\\n        ret.spd = int(uint(x.spd));\\r\\n        ret.inte = x.inte;\\r\\n        ret.def = int(uint(x.def));\\r\\n        ret.atk = int(uint(x.atk));\\r\\n        ret.sAtk = int(uint(x.sAtk));\\r\\n        ret.sDef = int(uint(x.sDef));\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n//Checks if the requirements are satisfied for a certain code\\r\\n//returns bool - is satisfied?\\r\\n// uint - the multiplier for the card's attack power\\r\\n// for most cases multiplier is 1\\r\\nfunction checkReqCode(\\r\\n        Hand memory atkHand,\\r\\n        Hand memory defHand,\\r\\n        uint256 reqCode,\\r\\n        bool isAttacker\\r\\n    ) internal view returns (bool, uint256) {\\r\\n        bool isTriggered = false;\\r\\n        uint256 multiplier = 1;\\r\\n        if (reqCode == 0) {\\r\\n            // No requirement\\r\\n            isTriggered = true;\\r\\n        } else if (reqCode == 1) {\\r\\n            // Intelligence of offense pepemon <= 5.\\r\\n            isTriggered = (atkHand.currentBCstats.inte <= 5 );\\r\\n        } else if (reqCode == 2) {\\r\\n            // Number of defense cards of defense pepemon is 0.\\r\\n            isTriggered = true;\\r\\n            for (uint256 i = 0; i < defHand.currentBCstats.inte; i++) {\\r\\n                IPepemonCardOracle.SupportCardType supportCardType = _cardContract.getSupportCardTypeById(\\r\\n                    defHand.supportCardInHandIds[i]\\r\\n                );\\r\\n                if (supportCardType == IPepemonCardOracle.SupportCardType.DEFENSE) {\\r\\n                    isTriggered = false;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        } else if (reqCode == 3) {\\r\\n            // Each +2 offense cards of offense pepemon.\\r\\n            return countCards(atkHand, IPepemonCardOracle.SupportCardType.OFFENSE, 2);\\r\\n        } else if (reqCode == 4) {\\r\\n            // Each +3 offense cards of offense pepemon.\\r\\n            return countCards(atkHand, IPepemonCardOracle.SupportCardType.OFFENSE, 3);\\r\\n        } else if (reqCode == 5) {\\r\\n            // Each offense card of offense pepemon.\\r\\n            return countCards(atkHand, IPepemonCardOracle.SupportCardType.OFFENSE, 0);\\r\\n\\r\\n        } else if (reqCode == 6) {\\r\\n            // Each +3 defense card of defense pepemon.\\r\\n            return countCards(defHand, IPepemonCardOracle.SupportCardType.DEFENSE, 3);\\r\\n        } else if (reqCode == 7) {\\r\\n            // Each +4 defense card of defense pepemon.\\r\\n            return countCards(defHand, IPepemonCardOracle.SupportCardType.DEFENSE, 4);\\r\\n        } else if (reqCode == 8) {\\r\\n            // Intelligence of defense pepemon <= 5.\\r\\n            isTriggered = (defHand.currentBCstats.inte <= 5 );\\r\\n        } else if (reqCode == 9) {\\r\\n            // Intelligence of defense pepemon >= 7.\\r\\n            isTriggered = (defHand.currentBCstats.inte >= 7 );\\r\\n        } else if (reqCode == 10) {\\r\\n            // Offense pepemon is using strong attack\\r\\n            for (uint256 i = 0; i < atkHand.currentBCstats.inte; i++) {\\r\\n                IPepemonCardOracle.SupportCardStats memory card = _cardContract.getSupportCardById(\\r\\n                    atkHand.supportCardInHandIds[i]\\r\\n                );\\r\\n                if (card.supportCardType == IPepemonCardOracle.SupportCardType.STRONG_OFFENSE) {\\r\\n                    isTriggered = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            multiplier = 1;\\r\\n        } else if (reqCode == 11) {\\r\\n            // The current HP is less than 50% of max HP.\\r\\n            isTriggered = lessThanHalfHP(isAttacker ? atkHand : defHand);\\r\\n        }\\r\\n        return (isTriggered, multiplier);\\r\\n    }\\r\\n\\r\\n    function lessThanHalfHP(Hand memory hand) internal view returns (bool){\\r\\n        return hand.health * 2 <= int256(uint256(_cardContract.getBattleCardById(hand.battleCardId).hp));\\r\\n    }\\r\\n    \\r\\n    function countCards(Hand memory hand, IPepemonCardOracle.SupportCardType cardType, int basePower) internal view returns (bool, uint){\\r\\n        uint multiplier = 0;\\r\\n        for (uint256 i = 0; i < hand.currentBCstats.inte; i++) {\\r\\n            IPepemonCardOracle.SupportCardStats memory card = _cardContract.getSupportCardById(\\r\\n                hand.supportCardInHandIds[i]\\r\\n            );\\r\\n            if (card.supportCardType != cardType) {\\r\\n                continue;\\r\\n            }\\r\\n            IPepemonCardOracle.EffectOne memory effectOne = card.effectOne;\\r\\n            if (effectOne.basePower == basePower || basePower == 0) {\\r\\n                multiplier++;\\r\\n            }\\r\\n        }\\r\\n        return (multiplier>0, multiplier);\\r\\n    }\\r\\n\\r\\n    function resistanceWeaknessCal(Hand memory atkHand, Hand memory defHand) internal view returns (int){\\r\\n        int adjustment = 0;\\r\\n        uint battleIdAtk = atkHand.battleCardId;\\r\\n        uint battleIdDef = defHand.battleCardId;\\r\\n        IPepemonCardOracle.BattleCardTypes atkType = _cardContract.getBattleCardById(battleIdAtk).element;\\r\\n        IPepemonCardOracle.BattleCardTypes defType = _cardContract.getBattleCardById(battleIdDef).element;\\r\\n        IPepemonCardOracle.BattleCardTypes weakness = _cardContract.getWeakResist(defType).weakness;\\r\\n        IPepemonCardOracle.BattleCardTypes resistance = _cardContract.getWeakResist(defType).resistance;\\r\\n        if (atkType == weakness) adjustment = 2;\\r\\n        if (atkType == resistance) adjustment = -2;\\r\\n        return adjustment;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\",\"keccak256\":\"0xa54e3c2ea4673de0dc0d1a3ad4a99f41074fa83400d2ca98d36a3d17d8c562b9\",\"license\":\"MIT\"},\"contracts/PepemonCardDeck.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n//pragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"./iface/IPepemonFactory.sol\\\";\\r\\nimport \\\"./iface/IPepemonCardOracle.sol\\\";\\r\\nimport \\\"./lib/Arrays.sol\\\";\\r\\n\\r\\ncontract PepemonCardDeck is ERC721, ERC1155Holder, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct Deck {\\r\\n        uint256 battleCardId;\\r\\n        uint256 supportCardCount;\\r\\n        mapping(uint256 => SupportCardType) supportCardTypes;\\r\\n        uint256[] supportCardTypeList;\\r\\n    }\\r\\n\\r\\n    struct SupportCardType {\\r\\n        uint256 supportCardId;\\r\\n        uint256 count;\\r\\n        uint256 pointer;\\r\\n        bool isEntity;\\r\\n    }\\r\\n\\r\\n    struct SupportCardRequest {\\r\\n        uint256 supportCardId;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    uint256 public MAX_SUPPORT_CARDS;\\r\\n    uint256 public MIN_SUPPORT_CARDS;\\r\\n\\r\\n    // set this to 0 to disable minting test cards.\\r\\n    uint256 maxMintTestCardId;\\r\\n    uint256 minMintTestCardId;\\r\\n\\r\\n    uint256 nextDeckId;\\r\\n    address public battleCardAddress;\\r\\n    address public supportCardAddress;\\r\\n\\r\\n    mapping(uint256 => Deck) public decks;\\r\\n    mapping(address => uint256[]) public playerToDecks;\\r\\n\\r\\n    constructor() ERC721(\\\"Pepedeck\\\", \\\"Pepedeck\\\") {\\r\\n        nextDeckId = 1;\\r\\n        MAX_SUPPORT_CARDS = 60;\\r\\n        MIN_SUPPORT_CARDS = 40;\\r\\n        \\r\\n        minMintTestCardId = 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Override supportInterface .\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override(ERC721, ERC1155Receiver)\\r\\n        returns (bool)\\r\\n    {\\r\\n        return super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    // MODIFIERS\\r\\n    modifier sendersDeck(uint256 _deckId) {\\r\\n        require(msg.sender == ownerOf(_deckId), \\\"PepemonCardDeck: Not your deck\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // PUBLIC METHODS\\r\\n    function setBattleCardAddress(address _battleCardAddress) public onlyOwner {\\r\\n        battleCardAddress = _battleCardAddress;\\r\\n    }\\r\\n\\r\\n    function setSupportCardAddress(address _supportCardAddress) public onlyOwner {\\r\\n        supportCardAddress = _supportCardAddress;\\r\\n    }\\r\\n\\r\\n    function setMaxSupportCards(uint256 _maxSupportCards) public onlyOwner {\\r\\n        MAX_SUPPORT_CARDS = _maxSupportCards;\\r\\n    }\\r\\n\\r\\n    function setMinSupportCards(uint256 _minSupportCards) public onlyOwner {\\r\\n        MIN_SUPPORT_CARDS = _minSupportCards;\\r\\n    }\\r\\n\\r\\n    // ALLOW TEST MINTING\\r\\n    function setMintingCards(uint256 minCardId, uint256 maxCardId) public onlyOwner {\\r\\n        maxMintTestCardId = maxCardId;\\r\\n        minMintTestCardId = minCardId;\\r\\n    }\\r\\n    /**\\r\\n     * @dev right now there are 40 different cards that can be minted, but the maximum is configurable with maxMintTestCard. \\r\\n     * setting maxMintTestCard to 0 disables this card minting.\\r\\n     */\\r\\n    function mintCards() public {\\r\\n        require(maxMintTestCardId > 0, \\\"Minting test cards is disabled\\\");\\r\\n        IPepemonFactory(supportCardAddress).batchMint(minMintTestCardId, maxMintTestCardId, msg.sender);\\r\\n    }\\r\\n\\r\\n    function createDeck() public {\\r\\n        _safeMint(msg.sender, nextDeckId);\\r\\n        playerToDecks[msg.sender].push(nextDeckId);\\r\\n        nextDeckId = nextDeckId.add(1);\\r\\n    }\\r\\n\\r\\n    function addBattleCardToDeck(uint256 deckId, uint256 battleCardId) public sendersDeck(deckId) {\\r\\n        require(\\r\\n            IPepemonFactory(battleCardAddress).balanceOf(msg.sender, battleCardId) >= 1,\\r\\n            \\\"PepemonCardDeck: Don't own battle card\\\"\\r\\n        );\\r\\n\\r\\n        require(battleCardId != decks[deckId].battleCardId, \\\"PepemonCardDeck: Card already in deck\\\");\\r\\n\\r\\n        uint256 oldBattleCardId = decks[deckId].battleCardId;\\r\\n        decks[deckId].battleCardId = battleCardId;\\r\\n\\r\\n        IPepemonFactory(battleCardAddress).safeTransferFrom(msg.sender, address(this), battleCardId, 1, \\\"\\\");\\r\\n\\r\\n        returnBattleCardFromDeck(oldBattleCardId);\\r\\n    }\\r\\n\\r\\n    function removeBattleCardFromDeck(uint256 _deckId) public sendersDeck(_deckId) {\\r\\n        uint256 oldBattleCardId = decks[_deckId].battleCardId;\\r\\n\\r\\n        decks[_deckId].battleCardId = 0;\\r\\n\\r\\n        returnBattleCardFromDeck(oldBattleCardId);\\r\\n    }\\r\\n\\r\\n    function addSupportCardsToDeck(uint256 deckId, SupportCardRequest[] memory supportCards) public sendersDeck(deckId) {\\r\\n        for (uint256 i = 0; i < supportCards.length; i++) {\\r\\n            addSupportCardToDeck(deckId, supportCards[i].supportCardId, supportCards[i].amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeSupportCardsFromDeck(uint256 _deckId, SupportCardRequest[] memory _supportCards) public sendersDeck(_deckId) {\\r\\n        for (uint256 i = 0; i < _supportCards.length; i++) {\\r\\n            removeSupportCardFromDeck(_deckId, _supportCards[i].supportCardId, _supportCards[i].amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // INTERNALS\\r\\n    function addSupportCardToDeck(\\r\\n        uint256 _deckId,\\r\\n        uint256 _supportCardId,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        require(MAX_SUPPORT_CARDS >= decks[_deckId].supportCardCount.add(_amount), \\\"PepemonCardDeck: Deck overflow\\\");\\r\\n        require(\\r\\n            IPepemonFactory(supportCardAddress).balanceOf(msg.sender, _supportCardId) >= _amount,\\r\\n            \\\"PepemonCardDeck: You don't have enough of this card\\\"\\r\\n        );\\r\\n\\r\\n        if (!decks[_deckId].supportCardTypes[_supportCardId].isEntity) {\\r\\n            decks[_deckId].supportCardTypes[_supportCardId] = SupportCardType({\\r\\n                supportCardId: _supportCardId,\\r\\n                count: _amount,\\r\\n                pointer: decks[_deckId].supportCardTypeList.length,\\r\\n                isEntity: true\\r\\n            });\\r\\n\\r\\n            // Prepend the ID to the list\\r\\n            decks[_deckId].supportCardTypeList.push(_supportCardId);\\r\\n        } else {\\r\\n            SupportCardType storage supportCard = decks[_deckId].supportCardTypes[_supportCardId];\\r\\n            supportCard.count = supportCard.count.add(_amount);\\r\\n        }\\r\\n\\r\\n        decks[_deckId].supportCardCount = decks[_deckId].supportCardCount.add(_amount);\\r\\n\\r\\n        IPepemonFactory(supportCardAddress).safeTransferFrom(msg.sender, address(this), _supportCardId, _amount, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function removeSupportCardFromDeck(\\r\\n        uint256 _deckId,\\r\\n        uint256 _supportCardId,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        SupportCardType storage supportCardList = decks[_deckId].supportCardTypes[_supportCardId];\\r\\n        supportCardList.count = supportCardList.count.sub(_amount);\\r\\n\\r\\n        decks[_deckId].supportCardCount = decks[_deckId].supportCardCount.sub(_amount);\\r\\n\\r\\n        if (supportCardList.count == 0) {\\r\\n            uint256 lastItemIndex = decks[_deckId].supportCardTypeList.length - 1;\\r\\n\\r\\n            // update the pointer of the item to be swapped\\r\\n            uint256 lastSupportCardId = decks[_deckId].supportCardTypeList[lastItemIndex];\\r\\n            decks[_deckId].supportCardTypes[lastSupportCardId].pointer = supportCardList.pointer;\\r\\n\\r\\n            // swap the last item of the list with the one to be deleted\\r\\n            decks[_deckId].supportCardTypeList[supportCardList.pointer] = decks[_deckId].supportCardTypeList[lastItemIndex];\\r\\n            decks[_deckId].supportCardTypeList.pop();\\r\\n\\r\\n            delete decks[_deckId].supportCardTypes[_supportCardId];\\r\\n        }\\r\\n\\r\\n        IPepemonFactory(supportCardAddress).safeTransferFrom(address(this), msg.sender, _supportCardId, _amount, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function returnBattleCardFromDeck(uint256 _battleCardId) internal {\\r\\n        if (_battleCardId != 0) {\\r\\n            IPepemonFactory(battleCardAddress).safeTransferFrom(address(this), msg.sender, _battleCardId, 1, \\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // VIEWS\\r\\n    function getDeckCount(address player) public view returns (uint256) {\\r\\n        return playerToDecks[player].length;\\r\\n    }\\r\\n\\r\\n    function getBattleCardInDeck(uint256 _deckId) public view returns (uint256) {\\r\\n        return decks[_deckId].battleCardId;\\r\\n    }\\r\\n\\r\\n    function getCardTypesInDeck(uint256 _deckId) public view returns (uint256[] memory) {\\r\\n        Deck storage deck = decks[_deckId];\\r\\n\\r\\n        uint256[] memory supportCardTypes = new uint256[](deck.supportCardTypeList.length);\\r\\n\\r\\n        for (uint256 i = 0; i < deck.supportCardTypeList.length; i++) {\\r\\n            supportCardTypes[i] = deck.supportCardTypeList[i];\\r\\n        }\\r\\n\\r\\n        return supportCardTypes;\\r\\n    }\\r\\n\\r\\n    function getCountOfCardTypeInDeck(uint256 _deckId, uint256 _cardTypeId) public view returns (uint256) {\\r\\n        return decks[_deckId].supportCardTypes[_cardTypeId].count;\\r\\n    }\\r\\n\\r\\n    function getSupportCardCountInDeck(uint256 deckId) public view returns (uint256) {\\r\\n        return decks[deckId].supportCardCount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns array of support cards for a deck\\r\\n     * @param _deckId uint256 ID of the deck\\r\\n     */\\r\\n    function getAllSupportCardsInDeck(uint256 _deckId) public view returns (uint256[] memory) {\\r\\n        Deck storage deck = decks[_deckId];\\r\\n        uint256[] memory supportCards = new uint256[](deck.supportCardCount);\\r\\n        uint256 idx = 0;\\r\\n        for (uint256 i = 0; i < deck.supportCardTypeList.length; i++) {\\r\\n            uint256 supportCardId = deck.supportCardTypeList[i];\\r\\n            uint256 count = deck.supportCardTypes[supportCardId].count;\\r\\n            for (uint256 j = 0; j < count; j++) {\\r\\n                supportCards[idx++] = supportCardId;\\r\\n            }\\r\\n        }\\r\\n        return supportCards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Shuffles deck\\r\\n     * @param _deckId uint256 ID of the deck\\r\\n     */\\r\\n    function shuffleDeck(uint256 _deckId, uint256 _seed) public view returns (uint256[] memory) {\\r\\n        uint256[] memory totalSupportCards = getAllSupportCardsInDeck(_deckId);\\r\\n        return Arrays.shuffle(totalSupportCards, _seed);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x8d47f7db2ffb7cedba3027f383c418ff017057cbca2106e366e3e93f976534a1\",\"license\":\"MIT\"},\"contracts/PepemonMatchmaker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport \\\"./lib/AdminRole.sol\\\";\\r\\nimport \\\"./PepemonCardDeck.sol\\\";\\r\\nimport \\\"./lib/RewardPool.sol\\\";\\r\\nimport \\\"./lib/Elo.sol\\\";\\r\\nimport \\\"./iface/IPepemonCardOracle.sol\\\";\\r\\nimport \\\"./PepemonBattle.sol\\\";\\r\\n\\r\\ncontract PepemonMatchmaker is ERC1155Holder, ERC721Holder, AdminRole {\\r\\n    event BattleFinished(address indexed winner, address indexed loser, uint256 battleId);\\r\\n\\r\\n    struct waitingDeckData {\\r\\n        uint256 deckId;\\r\\n        uint256 enterTimestamp;\\r\\n    }\\r\\n\\r\\n    address private _battleAddress;\\r\\n    address private _deckAddress;\\r\\n    address private _rewardPoolAddress;\\r\\n    bool private _allowBattleAgainstOneself;\\r\\n    bool private _pveMode;\\r\\n\\r\\n    uint256 private immutable _defaultRanking;\\r\\n    uint256 private _matchRange = 300;\\r\\n    uint256 private _matchRangePerMinute = 1;\\r\\n    uint256 private _kFactor = 16;\\r\\n\\r\\n    mapping(uint256 => uint256) internal _waitingDecksIndex; // _waitingDecksIndex[deckId] -> index of waitingDecks\\r\\n    mapping(uint256 => address) public deckOwner;\\r\\n    waitingDeckData[] public waitingDecks;\\r\\n\\r\\n    mapping(address => uint256) public playerRanking;\\r\\n    address[] public leaderboardPlayers;\\r\\n\\r\\n    constructor (uint256 defaultRanking, address battleAddress, address deckAddress, address rewardPoolAddress) {\\r\\n        _defaultRanking = defaultRanking; // suggested: 2000\\r\\n        _battleAddress = battleAddress;\\r\\n        _deckAddress = deckAddress;\\r\\n        _rewardPoolAddress = rewardPoolAddress;\\r\\n        _allowBattleAgainstOneself = false;\\r\\n    }\\r\\n\\r\\n    function setPveMode(bool enable) public onlyAdmin {\\r\\n        _pveMode = enable;\\r\\n    }\\r\\n\\r\\n    function addPveDeck(uint256 deckId) public onlyAdmin {\\r\\n        require(_pveMode == true);\\r\\n\\r\\n        // must be set, unless PvE requires no ranking (to be confirmed)\\r\\n        if (playerRanking[msg.sender] == 0) {\\r\\n            playerRanking[msg.sender] = _defaultRanking;\\r\\n            leaderboardPlayers.push(msg.sender);\\r\\n        }\\r\\n\\r\\n        addWaitingDeck(deckId);\\r\\n    }\\r\\n\\r\\n    function removePveDeck(uint256 deckId) public onlyAdmin {\\r\\n        require(_pveMode == true);\\r\\n        removeWaitingDeck(deckId);\\r\\n    }\\r\\n\\r\\n    function setAllowBattleAgainstOneself(bool allow) public onlyAdmin {\\r\\n        _allowBattleAgainstOneself = allow;\\r\\n    }\\r\\n\\r\\n    function setDeckContractAddress(address deckContractAddress) public onlyAdmin {\\r\\n        _deckAddress = deckContractAddress;\\r\\n    }\\r\\n\\r\\n    function setBattleContractAddress(address battleContractAddress) public onlyAdmin {\\r\\n        _battleAddress = battleContractAddress;\\r\\n    }\\r\\n\\r\\n    function setRewardPoolAddress(address rewardPoolAddress) public onlyAdmin {\\r\\n        _rewardPoolAddress = rewardPoolAddress;\\r\\n    }\\r\\n\\r\\n    function setMatchRange(uint256 matchRange, uint256 matchRangePerMinute) public onlyAdmin {\\r\\n        _matchRange = matchRange;\\r\\n        _matchRangePerMinute = matchRangePerMinute;\\r\\n    }\\r\\n\\r\\n    function forceExit(uint256 deckId) public onlyAdmin {\\r\\n        removeWaitingDeck(deckId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Dictates the rate of change, has a direct influence on how much a player wins/loses in the ranking\\r\\n     * @param kFactor Value used to calculate the rate of change in getEloRatingChange\\r\\n     */\\r\\n    function setKFactor(uint256 kFactor) public onlyAdmin {\\r\\n        _kFactor = kFactor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Tells whether or not this contract is operating in PvE mode. When in PvE mode, players cannot fight against\\r\\n     * each other (because PvE is the opposite of PvP).\\r\\n     */\\r\\n    function isPveMode() public view returns(bool) {\\r\\n        return _pveMode;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of players currently on the leaderboard.\\r\\n     * @return The number of players currently on the leaderboard.\\r\\n     */\\r\\n    function leaderboardPlayersCount() public view returns(uint256) {\\r\\n        return leaderboardPlayers.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rankings and addresses of players on the leaderboard, within a given range of indices.\\r\\n     * @param count The number of rankings to return.\\r\\n     * @param offset The index of the first ranking to return.\\r\\n     * @return addresses An array of player addresses corresponding to the returned rankings.\\r\\n     * @return rankings An array of ranking values for the returned players.\\r\\n     * @dev Requires that `count` is less than or equal to the number of players on the leaderboard minus `offset`, and that `offset` is less than the number of players on the leaderboard.\\r\\n     */\\r\\n    function getPlayersRankings(\\r\\n        uint256 count, \\r\\n        uint256 offset\\r\\n    ) public view returns (address[] memory addresses, uint256[] memory rankings) {\\r\\n        require(offset < leaderboardPlayers.length, \\\"Invalid offset\\\");\\r\\n        \\r\\n        if(count - offset > leaderboardPlayers.length) {\\r\\n            count = leaderboardPlayers.length;\\r\\n        }\\r\\n\\r\\n        addresses = new address[](count);\\r\\n        rankings = new uint256[](count);\\r\\n\\r\\n        for (uint256 i = offset; i < offset + count; ++i) {\\r\\n            address playerAddress = leaderboardPlayers[i];\\r\\n            addresses[i - offset] = playerAddress;\\r\\n            rankings[i - offset] = playerRanking[playerAddress];\\r\\n        }\\r\\n        return (addresses, rankings);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Tries to initiate a battle using a specified deck. Opponents are not other players but a set of decks added by admins.\\r\\n     * @dev This function cannot be used if _pveMode is set to false. In that case, players should join using \\\"enter\\\" instead, which \\r\\n     * allows them to fight each other.\\r\\n     * @param deckId The Deck of who called this function\\r\\n     */\\r\\n    function enterPve(uint256 deckId) public {\\r\\n        require(msg.sender == PepemonCardDeck(_deckAddress).ownerOf(deckId), \\\"PepemonMatchmaker: Not your deck\\\");\\r\\n        require(PepemonCardDeck(_deckAddress).getBattleCardInDeck(deckId) != 0, \\\"PepemonMatchmaker: Invalid battlecard\\\");\\r\\n        require(_pveMode == true, \\\"PepemonMatchmaker: PvE mode disabled\\\");\\r\\n\\r\\n        // Make sure the player has the minimum amount of support cards required\\r\\n        (,uint256 supportCardCount) = PepemonCardDeck(_deckAddress).decks(deckId);\\r\\n        require(supportCardCount >= PepemonCardDeck(_deckAddress).MIN_SUPPORT_CARDS(), \\\"PepemonMatchmaker: Not enough support cards\\\");\\r\\n\\r\\n        // If playerRanking is empty, set default ranking\\r\\n        if (playerRanking[msg.sender] == 0) {\\r\\n            playerRanking[msg.sender] = _defaultRanking;\\r\\n            leaderboardPlayers.push(msg.sender);\\r\\n        }\\r\\n\\r\\n        // Get a matchmaking opponent\\r\\n        uint256 opponentDeckId = getPveMatchmakingOpponent(deckId);\\r\\n\\r\\n        // If one is found then start the battle, otherwise revert the transaction because someone forgot to add the opponents\\r\\n        if (opponentDeckId > 0) {\\r\\n            // start battle\\r\\n            processMatch(deckId, opponentDeckId);\\r\\n        } else {\\r\\n            // should only happen if an admin forgot to add decks to this contract\\r\\n            revert(\\\"PepemonMatchmaker: No PvE opponents available\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Tries to initiate a battle using a specified deck. If no opponents are found, the deck\\r\\n     * is placed in a wait list.\\r\\n     * @dev This function cannot be used if _pveMode is set to true, players should join using \\\"enterPve\\\" instead.\\r\\n     * @param deckId The Deck of who called this function\\r\\n     */\\r\\n    function enter(uint256 deckId) public {\\r\\n        require(msg.sender == PepemonCardDeck(_deckAddress).ownerOf(deckId), \\\"PepemonMatchmaker: Not your deck\\\");\\r\\n        require(PepemonCardDeck(_deckAddress).getBattleCardInDeck(deckId) != 0, \\\"PepemonMatchmaker: Invalid battlecard\\\");\\r\\n        require(_pveMode == false, \\\"PepemonMatchmaker: PvE mode enabled\\\");\\r\\n\\r\\n        // Make sure the player has the minimum amount of support cards required\\r\\n        (,uint256 supportCardCount) = PepemonCardDeck(_deckAddress).decks(deckId);\\r\\n        require(supportCardCount >= PepemonCardDeck(_deckAddress).MIN_SUPPORT_CARDS(), \\\"PepemonMatchmaker: Not enough support cards\\\");\\r\\n\\r\\n        // If playerRanking is empty, set default ranking\\r\\n        if (playerRanking[msg.sender] == 0) {\\r\\n            playerRanking[msg.sender] = _defaultRanking;\\r\\n            leaderboardPlayers.push(msg.sender);\\r\\n        }\\r\\n\\r\\n        // Try find matchmaking partner\\r\\n        uint256 opponentDeckId = findMatchmakingOpponent(deckId);\\r\\n\\r\\n        // If one is found then start the battle, otherwise put in a wait list\\r\\n        if (opponentDeckId > 0) {\\r\\n            // start battle\\r\\n            processMatch(deckId, opponentDeckId);\\r\\n            // prevent other matches from starting immediately after this one finishes\\r\\n            removeWaitingDeck(opponentDeckId);\\r\\n        } else {\\r\\n            addWaitingDeck(deckId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers a deck back to its owner and removes from the wait list\\r\\n     * @param deckId The Deck of the owner\\r\\n     */\\r\\n    function exit(uint256 deckId) public {\\r\\n        require(waitingDecks.length > 0 && waitingDecks[_waitingDecksIndex[deckId]].deckId != 0, \\\"PepemonMatchmaker: Deck is not in the wait list\\\");\\r\\n        require(msg.sender == deckOwner[deckId], \\\"PepemonMatchmaker: Not your deck\\\");\\r\\n        removeWaitingDeck(deckId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the Elo change based on the winner's and loser's ratings.\\r\\n     * @dev The returned number has 2 decimals of precision, so 1501 = 15.01 Elo change\\r\\n     */\\r\\n    function getEloRatingChange(uint256 winnerRating, uint256 loserRating) public view returns (uint256) {\\r\\n        (uint256 change,) = Elo.ratingChange(winnerRating, loserRating, 100, _kFactor);\\r\\n        return change;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the number of waiting decks\\r\\n     */\\r\\n    function getWaitingCount() public view returns (uint256) {\\r\\n        return waitingDecks.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers a deck from its owner onto this contract, then adds the deck to the wait list\\r\\n     * @param deckId The Deck of the owner\\r\\n     */\\r\\n    function addWaitingDeck(uint256 deckId) internal {\\r\\n        deckOwner[deckId] = msg.sender;\\r\\n        PepemonCardDeck(_deckAddress).safeTransferFrom(msg.sender, address(this), deckId, \\\"\\\");\\r\\n\\r\\n        _waitingDecksIndex[deckId] = waitingDecks.length;\\r\\n        waitingDecks.push(waitingDeckData(deckId, block.timestamp));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes a deck from the wait list\\r\\n     * @dev Works by replacing the current element by the last element of the array. See https://stackoverflow.com/a/74668959\\r\\n     * @param deckId The Deck of the owner\\r\\n     */\\r\\n    function removeWaitingDeck(uint256 deckId) internal {\\r\\n        // Transfer deck back to owner\\r\\n        PepemonCardDeck(_deckAddress).safeTransferFrom(address(this), deckOwner[deckId], deckId, \\\"\\\");\\r\\n        delete deckOwner[deckId];\\r\\n\\r\\n        uint256 lastItemIndex = waitingDecks.length - 1;\\r\\n\\r\\n        uint256 lastDeckId = waitingDecks[lastItemIndex].deckId;\\r\\n\\r\\n        // update the index of the item to be swapped \\r\\n        _waitingDecksIndex[lastDeckId] = _waitingDecksIndex[deckId];\\r\\n\\r\\n        // swap the last item of the list with the one to be deleted\\r\\n        waitingDecks[_waitingDecksIndex[deckId]] = waitingDecks[lastItemIndex];\\r\\n        waitingDecks.pop();\\r\\n        delete _waitingDecksIndex[deckId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Performs the battle between player 1's and player 2's deck, sends a reward for the winner,\\r\\n     * and ajust their ranking\\r\\n     * @param player1deckId Deck of the first player\\r\\n     * @param player2deckId Deck of the second player\\r\\n     */\\r\\n    function processMatch(uint256 player1deckId, uint256 player2deckId) internal {\\r\\n        // Evaluate the battle winner\\r\\n        (address winner, address loser, uint256 battleId) = doBattle(player1deckId, player2deckId);\\r\\n        // Declare loser and winner\\r\\n        emit BattleFinished(winner, loser, battleId);\\r\\n\\r\\n        // Send a reward to the winner\\r\\n        RewardPool(_rewardPoolAddress).sendReward(battleId, winner);\\r\\n\\r\\n        // Adjust ranking accordingly. Change is adjusted to remove the extra precision from getEloRatingChange\\r\\n        uint256 change = getEloRatingChange(playerRanking[winner], playerRanking[loser]) / 100;\\r\\n        playerRanking[winner] += change;\\r\\n        // Prevent underflow or rank reset if it gets below or equal to zero. Unlikely, but possible.\\r\\n        if(int256(playerRanking[loser]) - int256(change) > 0) {\\r\\n            playerRanking[loser] = playerRanking[loser] - change;\\r\\n        } else {\\r\\n            playerRanking[loser] = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Takes one random deckId from the waiting list, which in pve mode contains decks set by admins instead of other player's decks\\r\\n     * @param deckId Deck of the current player trying to start a match, only used for added entropy\\r\\n     * @return opponentDeckId Deck of the opponent, if any. 0 when none are available\\r\\n     */\\r\\n    function getPveMatchmakingOpponent(uint256 deckId) internal view returns (uint256) {\\r\\n        if (waitingDecks.length == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        // Take one of the random pve decks\\r\\n        uint256 index = uint256(keccak256(abi.encodePacked(uint256(63), deckId, block.timestamp))) % waitingDecks.length;\\r\\n        return waitingDecks[index].deckId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tries to find an opponent's deck based off all waiting player's ratings. The acceptable\\r\\n     * difference between players ratings is increased over time by an amount defined by _matchRangePerMinute\\r\\n     * @param deckId Deck of the current player trying to start a match\\r\\n     * @return opponentDeckId Deck of the opponent, if found. 0 when not found\\r\\n     */\\r\\n    function findMatchmakingOpponent(uint256 deckId) internal view returns (uint256) {\\r\\n        // Find a waiting deck with a ranking that is within matchRange\\r\\n        for (uint256 i = 0; i < waitingDecks.length; ++i) {\\r\\n            uint256 currentIterDeck = waitingDecks[i].deckId;\\r\\n\\r\\n            // Skip own deck, as well as other decks of the same owner IF _allowBattleAgainstOneself is false\\r\\n            if (i == deckId || (!_allowBattleAgainstOneself && msg.sender == deckOwner[currentIterDeck])) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            // increase precision to allow increasing playerMatchRange every second\\r\\n            uint256 mins = (120 * (block.timestamp - waitingDecks[i].enterTimestamp)) / 60;\\r\\n            uint256 playerMatchRange = _matchRange + (mins * _matchRangePerMinute) / 120;\\r\\n            // Assume deckOwner[deckId] is msg.sender, because we are not storing msg.sender in deckOwner[deckId], saving gas\\r\\n            if (\\r\\n                // instead of doing the following:\\r\\n                // playerRanking[msg.sender] > (playerRanking[deckOwner[currentIterDeck]] - playerMatchRange) &&\\r\\n                // we invert the math operation to avoid casting everything to int256, thus saving some gas\\r\\n                (playerRanking[msg.sender] + playerMatchRange) > playerRanking[deckOwner[currentIterDeck]] &&\\r\\n                playerRanking[msg.sender] < (playerRanking[deckOwner[currentIterDeck]] + playerMatchRange)\\r\\n            ) {\\r\\n                return waitingDecks[i].deckId;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates a new battle in the PepemonBattle contract and executes the battle logic\\r\\n     * @param player1deckId Deck of the first player\\r\\n     * @param player2deckId Deck of the second player\\r\\n     * @return winner Address of the winner\\r\\n     * @return loser Address of the loser\\r\\n     * @return battleId Random seed generated for the battle\\r\\n     */\\r\\n    function doBattle(uint256 player1deckId, uint256 player2deckId) internal returns (address, address, uint256) {\\r\\n        // Assume deckOwner[player1deckId] is msg.sender, because we are not storing msg.sender in deckOwner[player1deckId], saving gas\\r\\n        (PepemonBattle.Battle memory battle, uint256 battleId) = PepemonBattle(_battleAddress).createBattle(\\r\\n            msg.sender,\\r\\n            player1deckId,\\r\\n            deckOwner[player2deckId],\\r\\n            player2deckId\\r\\n        );\\r\\n        (, address winner) = PepemonBattle(_battleAddress).goForBattle(battle);\\r\\n        address loser = (winner == msg.sender ? deckOwner[player2deckId] : msg.sender);\\r\\n        return (winner, loser, battleId);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4bf41cbf2a0c4976227b11e0f9660cde29574ac844c74e86ce3e0ccbe98e0400\",\"license\":\"MIT\"},\"contracts/iface/IPepemonCardOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\nThis contract acts as the oracle, it contains battling information for both the Pepemon Battle and Support cards\\r\\n**/\\r\\ninterface IPepemonCardOracle {\\r\\n\\r\\n    enum SupportCardType {\\r\\n        OFFENSE,\\r\\n        STRONG_OFFENSE,\\r\\n        DEFENSE,\\r\\n        STRONG_DEFENSE\\r\\n    }\\r\\n\\r\\n    enum EffectTo {\\r\\n        ATTACK,\\r\\n        STRONG_ATTACK,\\r\\n        DEFENSE,\\r\\n        STRONG_DEFENSE,\\r\\n        SPEED,\\r\\n        INTELLIGENCE\\r\\n    }\\r\\n\\r\\n    enum EffectFor {\\r\\n        ME,\\r\\n        ENEMY\\r\\n    }\\r\\n\\r\\n    enum BattleCardTypes{\\r\\n        FIRE,\\r\\n        GRASS,\\r\\n        WATER,\\r\\n        LIGHTNING,\\r\\n        WIND,\\r\\n        POISON,\\r\\n        GHOST,\\r\\n        FAIRY,\\r\\n        EARTH,\\r\\n        UNKNOWN,\\r\\n        NONE\\r\\n    }\\r\\n\\r\\n    struct BattleCardStats {\\r\\n        uint256 battleCardId;\\r\\n        BattleCardTypes element;\\r\\n        uint16 hp; // hitpoints\\r\\n        uint16 spd; // speed\\r\\n        uint16 inte; // intelligence\\r\\n        uint16 def; // defense\\r\\n        uint16 atk; // attack\\r\\n        uint16 sAtk; // special attack\\r\\n        uint16 sDef; // special defense\\r\\n    }\\r\\n\\r\\n    struct SupportCardStats {\\r\\n        uint256 supportCardId;\\r\\n        SupportCardType supportCardType;\\r\\n        EffectOne effectOne;\\r\\n        EffectMany effectMany;\\r\\n        // If true, duplicate copies of the card in the same turn will have no extra effect.\\r\\n        bool unstackable;\\r\\n        // This property is for EffectMany now.\\r\\n        // If true, assume the card is already in effect\\r\\n        // then the same card drawn and used within a number of turns does not extend or reset duration of the effect.\\r\\n        bool unresettable;\\r\\n    }\\r\\n\\r\\n    struct EffectOne {\\r\\n        // If power is 0, it is equal to the total of all normal offense/defense cards in the current turn.\\r\\n        \\r\\n        //basePower = power if req not met\\r\\n        int16 basePower;\\r\\n\\r\\n        //triggeredPower = power if req met\\r\\n        int16 triggeredPower;\\r\\n        EffectTo effectTo;\\r\\n        EffectFor effectFor;\\r\\n        uint16 reqCode; //requirement code\\r\\n    }\\r\\n\\r\\n    struct EffectMany {\\r\\n        int16 power;\\r\\n        uint16 numTurns;\\r\\n        EffectTo effectTo;\\r\\n        EffectFor effectFor;\\r\\n        uint16 reqCode; //requirement code\\r\\n    }\\r\\n\\r\\n    //Struct for keeping track of weakness / resistance\\r\\n    struct elementWR{\\r\\n        BattleCardTypes weakness;\\r\\n        BattleCardTypes resistance;\\r\\n    }\\r\\n\\r\\n    // mappings\\r\\n    function battleCardStats(uint256 x) view external returns (BattleCardStats memory);\\r\\n    \\r\\n    function supportCardStats(uint256 x) view external returns (SupportCardStats memory);\\r\\n    \\r\\n    function elementDecode(BattleCardTypes x) view external returns (string memory);\\r\\n    \\r\\n    function weakResist(BattleCardTypes x) view external returns (elementWR memory);\\r\\n\\r\\n    // other functions\\r\\n    function addBattleCard(BattleCardStats memory cardData) external;\\r\\n\\r\\n    function updateBattleCard(BattleCardStats memory cardData) external;\\r\\n\\r\\n    function getBattleCardById(uint256 _id) view external returns (BattleCardStats memory);\\r\\n\\r\\n    function addSupportCard(SupportCardStats memory cardData) external;\\r\\n\\r\\n    function updateSupportCard(SupportCardStats memory cardData) external;\\r\\n\\r\\n    function getSupportCardById(uint256 _id) view  external returns (SupportCardStats memory);\\r\\n\\r\\n    function getWeakResist(BattleCardTypes element) view  external returns (elementWR memory);\\r\\n\\r\\n    function getSupportCardTypeById(uint256 _id) view external returns (SupportCardType);\\r\\n}\\r\\n\",\"keccak256\":\"0x363ca2212ab0c9878d383244b9d74a204f455c25b5341229a79cc3d5404c61be\",\"license\":\"MIT\"},\"contracts/iface/IPepemonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPepemonFactory {\\r\\n    function safeTransferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _id,\\r\\n        uint256 _amount,\\r\\n        bytes calldata _data\\r\\n    ) external;\\r\\n\\r\\n    function setApprovalForAll(\\r\\n        address _operator,\\r\\n        bool _approved\\r\\n    ) external;\\r\\n\\r\\n    function balanceOf(\\r\\n        address _owner, \\r\\n        uint256 _id\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function airdrop(\\r\\n        uint256 _id,\\r\\n        address[] memory _addresses\\r\\n    ) external;\\r\\n\\r\\n    function batchMint(\\r\\n        uint start, \\r\\n        uint end, \\r\\n        address to) \\r\\n    external;\\r\\n\\r\\n    function addMinter(\\r\\n        address account\\r\\n    ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x8d53435857db30870aef3bf5e7ab4ebbdc73dda9b7f05b90d406cee0a5848cbe\",\"license\":\"MIT\"},\"contracts/lib/AdminRole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract AdminRole {\\n  using Roles for Roles.Role;\\n\\n  event AdminAdded(address indexed account);\\n  event AdminRemoved(address indexed account);\\n\\n  Roles.Role private admins;\\n\\n  constructor() {\\n    _addAdmin(msg.sender);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(isAdmin(msg.sender));\\n    _;\\n  }\\n\\n  function isAdmin(address account) public view returns (bool) {\\n    return admins.has(account);\\n  }\\n\\n  function addAdmin(address account) public onlyAdmin {\\n    _addAdmin(account);\\n  }\\n\\n  function renounceAdmin() public {\\n    _removeAdmin(msg.sender);\\n  }\\n\\n  function _addAdmin(address account) internal {\\n    admins.add(account);\\n    emit AdminAdded(account);\\n  }\\n\\n  function _removeAdmin(address account) internal {\\n    admins.remove(account);\\n    emit AdminRemoved(account);\\n  }\\n}\",\"keccak256\":\"0x087322ecbf7bdc39315bedc5ec603149a119a35910f82ceb131820c1b7bb9804\",\"license\":\"MIT\"},\"contracts/lib/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Arrays {\\n    //Shuffles an array of uints with random seed\\n    function shuffle(uint256[] memory _elements, uint256 _seed) internal pure returns (uint256[] memory) {\\n        for (uint256 i = 0; i < _elements.length; i++) {\\n            //Pick random index to swap current element with\\n            uint256 n = i + _seed % (_elements.length - i);\\n\\n            //swap elements\\n            uint256 temp = _elements[n];\\n            _elements[n] = _elements[i];\\n            _elements[i] = temp;\\n\\n            //Create new pseudorandom number using seed.\\n            _seed = uint(keccak256(abi.encodePacked(_seed)));\\n        }\\n        return _elements;\\n    }\\n}\\n\",\"keccak256\":\"0x61371b66c2b9849ea3837a60073233c577f8978017339fcd3bf169cb498a1828\",\"license\":\"MIT\"},\"contracts/lib/ChainLinkRngOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\r\\nimport \\\"./AdminRole.sol\\\";\\r\\n\\r\\nabstract contract ChainLinkRngOracle is VRFConsumerBase, AdminRole {\\r\\n    bytes32 immutable keyHash;\\r\\n    bytes32 public lastRequestId;\\r\\n    uint256 internal fee;\\r\\n\\r\\n    address constant maticLink = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\\r\\n    address constant maticVrfCoordinator = 0x3d2341ADb2D31f1c5530cDC622016af293177AE0;\\r\\n    bytes32 constant maticKeyHash = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;\\r\\n\\r\\n    address constant mumbaiLink = 0x326C977E6efc84E512bB9C30f76E30c160eD06FB;\\r\\n    address constant mumbaiVrfCoordinator = 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255;\\r\\n    bytes32 constant mumbaiKeyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;\\r\\n\\r\\n    address constant fantomTestnetLink = 0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F;\\r\\n    address constant fantomTestnetVrfCoordinator = 0xbd13f08b8352A3635218ab9418E340c60d6Eb418;\\r\\n    bytes32 constant fantomTestnetKeyHash = 0x121a143066e0f2f08b620784af77cccb35c6242460b4a8ee251b4b416abaebd4;\\r\\n\\r\\n    address constant fantomLink = 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407;\\r\\n    address constant fantomVrfCoordinator = 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634;\\r\\n    bytes32 constant fantomKeyHash = 0x5881eea62f9876043df723cf89f0c2bb6f950da25e9dfe66995c24f919c8f8ab;\\r\\n\\r\\n\\r\\n\\r\\n    mapping(bytes32 => uint256) internal results;\\r\\n\\r\\n    constructor() VRFConsumerBase(fantomTestnetVrfCoordinator, fantomTestnetLink) {\\r\\n        keyHash = fantomTestnetKeyHash;\\r\\n        fee = 1 ether / 1000;\\r\\n    }\\r\\n\\r\\n    //Get a new random number (paying link for it)\\r\\n    //Only callable by admin\\r\\n    function getNewRandomNumber() public onlyAdmin returns (bytes32 requestId) {\\r\\n        require(LINK.balanceOf(address(this)) >= fee, \\\"Not enough LINK - fill contract with faucet\\\");\\r\\n        lastRequestId = requestRandomness(keyHash, fee);\\r\\n        return lastRequestId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Callback function used by VRF Coordinator\\r\\n     */\\r\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\r\\n        results[requestId] = randomness;\\r\\n    }\\r\\n\\r\\n    function fetchNumberByRequestId(bytes32 _requestId) public view returns (uint256) {\\r\\n        return results[_requestId];\\r\\n    }\\r\\n\\r\\n    //Get most recent random number and use that as randomness source    \\r\\n    function getRandomNumber() public view returns (uint256){\\r\\n        return fetchNumberByRequestId(lastRequestId);        \\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd8a2e11145d4d975ccc5d32cfc4c2a35547edc104c47f4f009bf444a1ce38137\",\"license\":\"MIT\"},\"contracts/lib/Elo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// https://github.com/saucepoint/elo-lib/blob/main/src/Elo.sol\\npragma solidity ^0.8.0;\\n\\nimport {FixedPointMathLib as fp} from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nlibrary Elo {\\n    /// @notice Get the 16th root of a number, used in ELO calculations\\n    /// @dev Elo calculations require the 400th root (10 ^ (x / 400)), however this can be simplified to the 16th root (10 ^ ((x / 25) / 16))\\n    function sixteenthRoot(uint256 x) internal pure returns (uint256) {\\n        return fp.sqrt(fp.sqrt(fp.sqrt(fp.sqrt(x))));\\n    }\\n\\n    /// @notice Calculates the change in ELO rating, after a given outcome.\\n    /// @param ratingA the ELO rating of the player A\\n    /// @param ratingB the ELO rating of the player B\\n    /// @param score the score of the player A, scaled by 100. 100 = win, 50 = draw, 0 = loss\\n    /// @param kFactor the k-factor or development multiplier used to calculate the change in ELO rating. 20 is the typical value\\n    /// @return change the change in ELO rating of player A, with 2 decimals of precision. 1501 = 15.01 ELO change\\n    /// @return negative the directional change of player A's ELO. Opposite sign for player B\\n    function ratingChange(uint256 ratingA, uint256 ratingB, uint256 score, uint256 kFactor)\\n        internal\\n        pure\\n        returns (uint256 change, bool negative)\\n    {\\n        uint256 _kFactor; // scaled up `kFactor` by 100\\n        bool _negative = ratingB < ratingA;\\n        uint256 ratingDiff; // absolute value difference between `ratingA` and `ratingB`\\n\\n        unchecked {\\n            // scale up the inputs by a factor of 100\\n            // since our elo math is scaled up by 100 (to avoid low precision integer division)\\n            _kFactor = kFactor * 10_000;\\n            ratingDiff = _negative ? ratingA - ratingB : ratingB - ratingA;\\n        }\\n\\n        // checks against overflow/underflow, discovered via fuzzing\\n        // large rating diffs leads to 10^ratingDiff being too large to fit in a uint256\\n        require(ratingDiff < 1126, \\\"Rating difference too large\\\");\\n        // large rating diffs when applying the scale factor leads to underflow (800 - ratingDiff)\\n        if (_negative) require(ratingDiff < 800, \\\"Rating difference too large\\\");\\n\\n        // ----------------------------------------------------------------------\\n        // Below, we'll be running simplified versions of the following formulas:\\n        // expected score = 1 / (1 + 10 ^ (ratingDiff / 400))\\n        // elo change = kFactor * (score - expectedScore)\\n\\n        uint256 n; // numerator of the power, with scaling, (numerator of `ratingDiff / 400`)\\n        uint256 _powered; // the value of 10 ^ numerator\\n        uint256 powered; // the value of 16th root of 10 ^ numerator (fully resolved 10 ^ (ratingDiff / 400))\\n        uint256 kExpectedScore; // the expected score with K factor distributed\\n        uint256 kScore; // the actual score with K factor distributed\\n\\n        unchecked {\\n            // apply offset of 800 to scale the result by 100\\n            n = _negative ? 800 - ratingDiff : 800 + ratingDiff;\\n\\n            // (x / 400) is the same as ((x / 25) / 16))\\n            _powered = fp.rpow(10, n / 25, 1); // divide by 25 to avoid reach uint256 max\\n            powered = sixteenthRoot(_powered); // x ^ (1 / 16) is the same as 16th root of x\\n\\n            // given `change = kFactor * (score - expectedScore)` we can distribute kFactor to both terms\\n            kExpectedScore = _kFactor / (100 + powered); // both numerator and denominator scaled up by 100\\n            kScore = kFactor * score; // input score is already scaled up by 100\\n\\n            // determines the sign of the ELO change\\n            negative = kScore < kExpectedScore;\\n            change = negative ? kExpectedScore - kScore : kScore - kExpectedScore;\\n        }\\n    }\\n}\",\"keccak256\":\"0xc5b2722ba7968b94b70bde1b9e26f1068bbf3cad02856755fcfd74f8bd369b25\",\"license\":\"MIT\"},\"contracts/lib/RewardPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface RewardPool {\\n    /**\\n     * @dev Adds a single reward into the pool.\\n     * @param tokenAddress Reward address\\n     * @param tokenId Reward id\\n     */\\n    function addReward(address tokenAddress, uint256 tokenId) external; //onlyAdmin\\n\\n    /**\\n     * @dev Transfer an amount of a given token from the sender into the rewardPool\\n     * @param tokenAddress Reward address\\n     * @param tokenId Reward id\\n     * @param amount The number of items to be added to the pool.\\n     */\\n    function addRewards(address tokenAddress, uint256 tokenId, uint256 amount) external; //onlyAdmin\\n\\n    /**\\n     * @dev Takes a random reward from rewardPool and sends it to someone.\\n     * @param rngSeed RNG seed of a Battle\\n     * @param account Address of who will receive the reward\\n     */\\n    function sendReward(uint256 rngSeed, address account) external; //onlyAdmin\\n}\",\"keccak256\":\"0xcd34be3d5500450b808ad3dacce6b5581d00544900bff4eddbae972435950b28\",\"license\":\"MIT\"},\"contracts/lib/Roles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping (address => bool) bearer;\\n  }\\n\\n  /**\\n   * @dev give an account access to this role\\n   */\\n  function add(Role storage role, address account) internal {\\n    require(account != address(0));\\n    require(!has(role, account));\\n\\n    role.bearer[account] = true;\\n  }\\n\\n  /**\\n   * @dev remove an account's access to this role\\n   */\\n  function remove(Role storage role, address account) internal {\\n    require(account != address(0));\\n    require(has(role, account));\\n\\n    role.bearer[account] = false;\\n  }\\n\\n  /**\\n   * @dev check if an account has this role\\n   * @return bool\\n   */\\n  function has(Role storage role, address account)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    require(account != address(0));\\n    return role.bearer[account];\\n  }\\n}\",\"keccak256\":\"0xd66f1c8050d61971204bf1249496bd98b69fd79b2011a630767f817d7201b56c\",\"license\":\"MIT\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xefb05e8a873d48e94de34a758b809b04ff2cbf62918990fb809a22d83c0edde5\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60a060405261012c600455600160055560106006553480156200002157600080fd5b5060405162002d6238038062002d62833981016040819052620000449162000195565b6200004f33620000a0565b608093909352600180546001600160a01b039384166001600160a01b0319918216179091556002805492841692909116919091179055600380546001600160a81b03191691909216179055620001e9565b620000bb816000620000f260201b6200119a1790919060201c565b6040516001600160a01b038216907f44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e33990600090a250565b6001600160a01b0381166200010657600080fd5b62000112828262000142565b156200011d57600080fd5b6001600160a01b0316600090815260209190915260409020805460ff19166001179055565b60006001600160a01b0382166200015857600080fd5b506001600160a01b03166000908152602091909152604090205460ff1690565b80516001600160a01b03811681146200019057600080fd5b919050565b60008060008060808587031215620001ac57600080fd5b84519350620001be6020860162000178565b9250620001ce6040860162000178565b9150620001de6060860162000178565b905092959194509250565b608051612b4f620002136000396000818161083b01528181610b100152610eb90152612b4f6000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c8063889f004711610104578063b24cf5d7116100a2578063e19e89ab11610071578063e19e89ab1461042f578063f23a6e6114610441578063fa6285cc14610460578063fd12a4d21461048157600080fd5b8063b24cf5d7146103c1578063bc197c81146103d4578063d671581f146103f3578063d8963fc41461041c57600080fd5b80638bad0c0a116100de5780638bad0c0a1461037357806396dc76c41461037b578063a59f3e0c1461039b578063b2152aed146103ae57600080fd5b8063889f00471461032d5780638a062ab7146103585780638a78c3401461036b57600080fd5b8063458870381161017157806364375d291161014b57806364375d29146102e157806370480275146102f45780637f8661a11461030757806386db4df71461031a57600080fd5b8063458870381461029357806346864cd8146102a657806359509b7a146102b957600080fd5b8063150b7a02116101ad578063150b7a021461022457806324d7806c1461025b5780632acc9a9c1461026e5780633174d5071461028157600080fd5b806301ffc9a7146101d4578063086f99d4146101fc5780630a96263214610211575b600080fd5b6101e76101e236600461249e565b610494565b60405190151581526020015b60405180910390f35b61020f61020a3660046122bb565b6104cb565b005b61020f61021f36600461247c565b6104ff565b6102426102323660046123a9565b630a85bd0160e11b949350505050565b6040516001600160e01b031990911681526020016101f3565b6101e76102693660046122bb565b61052f565b61020f61027c366004612531565b61053b565b6009545b6040519081526020016101f3565b61020f6102a1366004612563565b61091c565b61020f6102b43660046122bb565b610939565b6102cc6102c7366004612531565b61096d565b604080519283526020830191909152016101f3565b6102856102ef366004612563565b61099b565b61020f6103023660046122bb565b6109b6565b61020f610315366004612531565b6109d4565b61020f610328366004612531565b610abe565b61034061033b366004612531565b610b7a565b6040516001600160a01b0390911681526020016101f3565b61020f610366366004612531565b610ba4565b600b54610285565b61020f610bbb565b6102856103893660046122bb565b600a6020526000908152604090205481565b61020f6103a9366004612531565b610bc6565b61020f6103bc366004612531565b610f49565b61020f6103cf3660046122bb565b610f76565b6102426103e23660046122fc565b63bc197c8160e01b95945050505050565b610340610401366004612531565b6008602052600090815260409020546001600160a01b031681565b61020f61042a36600461247c565b610faa565b600354600160a81b900460ff166101e7565b61024261044f366004612414565b63f23a6e6160e01b95945050505050565b61047361046e366004612563565b610fda565b6040516101f3929190612742565b61020f61048f366004612531565b611188565b60006001600160e01b03198216630271189760e51b14806104c557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6104d43361052f565b6104dd57600080fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6105083361052f565b61051157600080fd5b60038054911515600160a81b0260ff60a81b19909216919091179055565b60006104c581836111e6565b6002546040516331a9108f60e11b8152600481018390526001600160a01b0390911690636352211e9060240160206040518083038186803b15801561057f57600080fd5b505afa158015610593573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b791906122df565b6001600160a01b0316336001600160a01b0316146105f05760405162461bcd60e51b81526004016105e790612856565b60405180910390fd5b6002546040516352637b1f60e11b8152600481018390526001600160a01b039091169063a4c6f63e9060240160206040518083038186803b15801561063457600080fd5b505afa158015610648573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066c919061254a565b6106885760405162461bcd60e51b81526004016105e7906127c6565b600354600160a81b900460ff1615156001146106f25760405162461bcd60e51b8152602060048201526024808201527f506570656d6f6e4d617463686d616b65723a20507645206d6f64652064697361604482015263189b195960e21b60648201526084016105e7565b60025460405163a090195d60e01b8152600481018390526000916001600160a01b03169063a090195d90602401604080518083038186803b15801561073657600080fd5b505afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190612585565b915050600260009054906101000a90046001600160a01b03166001600160a01b03166330ecf94e6040518163ffffffff1660e01b815260040160206040518083038186803b1580156107bf57600080fd5b505afa1580156107d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f7919061254a565b8110156108165760405162461bcd60e51b81526004016105e79061280b565b336000908152600a602052604090205461089c57336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b60006108a78361121b565b905080156108be576108b983826112a0565b505050565b60405162461bcd60e51b815260206004820152602d60248201527f506570656d6f6e4d617463686d616b65723a204e6f20507645206f70706f6e6560448201526c6e747320617661696c61626c6560981b60648201526084016105e7565b6109253361052f565b61092e57600080fd5b600491909155600555565b6109423361052f565b61094b57600080fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6009818154811061097d57600080fd5b60009182526020909120600290910201805460019091015490915082565b6000806109ad84846064600654611466565b50949350505050565b6109bf3361052f565b6109c857600080fd5b6109d1816115ac565b50565b60095415801590610a1b5750600081815260076020526040902054600980549091908110610a0457610a04612abb565b906000526020600020906002020160000154600014155b610a7f5760405162461bcd60e51b815260206004820152602f60248201527f506570656d6f6e4d617463686d616b65723a204465636b206973206e6f74206960448201526e1b881d1a19481dd85a5d081b1a5cdd608a1b60648201526084016105e7565b6000818152600860205260409020546001600160a01b03163314610ab55760405162461bcd60e51b81526004016105e790612856565b6109d1816115ee565b610ac73361052f565b610ad057600080fd5b600354600160a81b900460ff161515600114610aeb57600080fd5b336000908152600a6020526040902054610b7157336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b6109d181611795565b600b8181548110610b8a57600080fd5b6000918252602090912001546001600160a01b0316905081565b610bad3361052f565b610bb657600080fd5b600655565b610bc4336118b9565b565b6002546040516331a9108f60e11b8152600481018390526001600160a01b0390911690636352211e9060240160206040518083038186803b158015610c0a57600080fd5b505afa158015610c1e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4291906122df565b6001600160a01b0316336001600160a01b031614610c725760405162461bcd60e51b81526004016105e790612856565b6002546040516352637b1f60e11b8152600481018390526001600160a01b039091169063a4c6f63e9060240160206040518083038186803b158015610cb657600080fd5b505afa158015610cca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cee919061254a565b610d0a5760405162461bcd60e51b81526004016105e7906127c6565b600354600160a81b900460ff1615610d705760405162461bcd60e51b815260206004820152602360248201527f506570656d6f6e4d617463686d616b65723a20507645206d6f646520656e61626044820152621b195960ea1b60648201526084016105e7565b60025460405163a090195d60e01b8152600481018390526000916001600160a01b03169063a090195d90602401604080518083038186803b158015610db457600080fd5b505afa158015610dc8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dec9190612585565b915050600260009054906101000a90046001600160a01b03166001600160a01b03166330ecf94e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e3d57600080fd5b505afa158015610e51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e75919061254a565b811015610e945760405162461bcd60e51b81526004016105e79061280b565b336000908152600a6020526040902054610f1a57336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b6000610f25836118fb565b90508015610f4057610f3783826112a0565b6108b9816115ee565b6108b983611795565b610f523361052f565b610f5b57600080fd5b600354600160a81b900460ff161515600114610ab557600080fd5b610f7f3361052f565b610f8857600080fd5b600380546001600160a01b0319166001600160a01b0392909216919091179055565b610fb33361052f565b610fbc57600080fd5b60038054911515600160a01b0260ff60a01b19909216919091179055565b600b54606090819083106110215760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a59081bd9999cd95d60921b60448201526064016105e7565b600b5461102e8486612a1d565b111561103a57600b5493505b836001600160401b0381111561105257611052612ad1565b60405190808252806020026020018201604052801561107b578160200160208202803683370190505b509150836001600160401b0381111561109657611096612ad1565b6040519080825280602002602001820160405280156110bf578160200160208202803683370190505b509050825b6110ce8585612993565b811015611180576000600b82815481106110ea576110ea612abb565b6000918252602090912001546001600160a01b03169050808461110d8785612a1d565b8151811061111d5761111d612abb565b6001600160a01b039283166020918202929092018101919091529082166000908152600a9091526040902054836111548785612a1d565b8151811061116457611164612abb565b60209081029190910101525061117981612a34565b90506110c4565b509250929050565b6111913361052f565b610ab557600080fd5b6001600160a01b0381166111ad57600080fd5b6111b782826111e6565b156111c157600080fd5b6001600160a01b0316600090815260209190915260409020805460ff19166001179055565b60006001600160a01b0382166111fb57600080fd5b506001600160a01b03166000908152602091909152604090205460ff1690565b60095460009061122d57506000919050565b60095460408051603f6020820152908101849052426060820152600091906080016040516020818303038152906040528051906020012060001c6112719190612a4f565b90506009818154811061128657611286612abb565b906000526020600020906002020160000154915050919050565b60008060006112af8585611ac1565b925092509250816001600160a01b0316836001600160a01b03167f9b5363c49f40791b738dbe0ba63e6fa52ed52213cf8d4a2f3724e1389d72f14f836040516112fa91815260200190565b60405180910390a36003546040516331f27b0760e01b8152600481018390526001600160a01b038581166024830152909116906331f27b0790604401600060405180830381600087803b15801561135057600080fd5b505af1158015611364573d6000803e3d6000fd5b5050506001600160a01b038085166000908152600a60205260408082205492861682528120549092506064916113999161099b565b6113a391906129ab565b6001600160a01b0385166000908152600a60205260408120805492935083929091906113d0908490612993565b90915550506001600160a01b0383166000908152600a60205260408120546113f99083906129de565b1315611441576001600160a01b0383166000908152600a6020526040902054611423908290612a1d565b6001600160a01b0384166000908152600a602052604090205561145e565b6001600160a01b0383166000908152600a60205260409020600190555b505050505050565b6000806127108302868610828161147f57888803611483565b8789035b905061046681106114d65760405162461bcd60e51b815260206004820152601b60248201527f526174696e6720646966666572656e636520746f6f206c61726765000000000060448201526064016105e7565b811561152d57610320811061152d5760405162461bcd60e51b815260206004820152601b60248201527f526174696e6720646966666572656e636520746f6f206c61726765000000000060448201526064016105e7565b60008060008060008661154457856103200161154a565b85610320035b945061155c600a601987046001611c3c565b935061156784611cfa565b925082606401888161157b5761157b612a79565b0491508b8b02905081811098508861159557818103611599565b8082035b9950505050505050505094509492505050565b6115b760008261119a565b6040516001600160a01b038216907f44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e33990600090a250565b600254600082815260086020526040808220549051635c46a7ef60e11b81523060048201526001600160a01b039182166024820152604481018590526080606482015260848101929092529091169063b88d4fde9060a401600060405180830381600087803b15801561166057600080fd5b505af1158015611674573d6000803e3d6000fd5b505050600082815260086020526040812080546001600160a01b03191690556009549091506116a590600190612a1d565b90506000600982815481106116bc576116bc612abb565b6000918252602080832060029092029091015485835260079091526040808320548284529220919091556009805491925090839081106116fe576116fe612abb565b9060005260206000209060020201600960076000868152602001908152602001600020548154811061173257611732612abb565b600091825260209091208254600290920201908155600191820154910155600980548061176157611761612aa5565b6000828152602080822060026000199094019384020182815560010182905591909255938152600790935250506040812055565b60008181526008602052604080822080546001600160a01b031916339081179091556002549151635c46a7ef60e11b81526004810191909152306024820152604481018490526080606482015260848101929092526001600160a01b03169063b88d4fde9060a401600060405180830381600087803b15801561181757600080fd5b505af115801561182b573d6000803e3d6000fd5b505060098054600085815260076020908152604080832084905580518082019091529687524290870190815260018301845592905293517f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af600290950294850155517f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7b0909301929092555050565b6118c4600082611d13565b6040516001600160a01b038216907fa3b62bc36326052d97ea62d63c3d60308ed4c3ea8ac079dd8499f1e9c4f80c0f90600090a250565b6000805b600954811015611ab85760006009828154811061191e5761191e612abb565b90600052602060002090600202016000015490508382148061196b5750600354600160a01b900460ff1615801561196b57506000818152600860205260409020546001600160a01b031633145b156119765750611aa8565b6000603c6009848154811061198d5761198d612abb565b906000526020600020906002020160010154426119aa9190612a1d565b6119b59060786129bf565b6119bf91906129ab565b905060006078600554836119d391906129bf565b6119dd91906129ab565b6004546119ea9190612993565b6000848152600860209081526040808320546001600160a01b03168352600a9091528082205433835291205491925090611a25908390612993565b118015611a6f57506000838152600860209081526040808320546001600160a01b03168352600a909152902054611a5d908290612993565b336000908152600a6020526040902054105b15611aa45760098481548110611a8757611a87612abb565b906000526020600020906002020160000154945050505050919050565b5050505b611ab181612a34565b90506118ff565b50600092915050565b6001546000828152600860205260408082205490516331acd38760e21b8152336004820152602481018690526001600160a01b039182166044820152606481018590529192839283928392839291169063c6b34e1c90608401611c2060405180830381600087803b158015611b3557600080fd5b505af1158015611b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b6d9190612502565b600154604051637cdb32cd60e01b81529294509092506000916001600160a01b0390911690637cdb32cd90611ba690869060040161288b565b611c206040518083038186803b158015611bbf57600080fd5b505afa158015611bd3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bf791906124c8565b9150600090506001600160a01b0382163314611c135733611c2c565b6000888152600860205260409020546001600160a01b03165b9199919850919650945050505050565b6000838015611cdc57600184168015611c5757859250611c5b565b8392505b508260011c8460011c94505b8415611cd6578560801c15611c7b57600080fd5b85860281810181811015611c8e57600080fd5b8590049650506001851615611ccb578583028387820414611cb4578615611cb457600080fd5b81810181811015611cc457600080fd5b8590049350505b8460011c9450611c67565b50611cf2565b838015611cec5760009250611cf0565b8392505b505b509392505050565b60006104c5611d0e611d0e611d0e85611d5b565b611d5b565b6001600160a01b038116611d2657600080fd5b611d3082826111e6565b611d3957600080fd5b6001600160a01b0316600090815260209190915260409020805460ff19169055565b600181600160801b8110611d745760409190911b9060801c5b680100000000000000008110611d8f5760209190911b9060401c5b6401000000008110611da65760109190911b9060201c5b620100008110611dbb5760089190911b9060101c5b6101008110611dcf5760049190911b9060081c5b60108110611de25760029190911b9060041c5b60088110611df1578160011b91505b5080820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c80820481811015611e2e578091505b50919050565b600082601f830112611e4557600080fd5b611e4d61291f565b8083856103c086011115611e6057600080fd5b60005b6005811015611f265781870360c080821215611e7e57600080fd5b611e866128f7565b84518152602060a080601f1986011215611e9f57600080fd5b611ea761291f565b9450818701518060010b8114611ebc57600080fd5b85526040611ecb8882016122a4565b8387015260608089015160068110611ee257600080fd5b8083890152506080915081890151611ef981612b0c565b90870152611f088883016122a4565b90860152508181019390935286529401939190910190600101611e63565b509095945050505050565b600082601f830112611f4257600080fd5b6040516107808082018281106001600160401b0382111715611f6657611f66612ad1565b6040528184828101871015611f7a57600080fd5b600092505b603c831015611f9f57805182526001929092019160209182019101611f7f565b509195945050505050565b600082601f830112611fbb57600080fd5b6040516101008082018281106001600160401b0382111715611fdf57611fdf612ad1565b6040528184828101871015611ff357600080fd5b600092505b6008831015611f9f57805182526001929092019160209182019101611ff8565b600082601f83011261202957600080fd5b813560206001600160401b0382111561204457612044612ad1565b8160051b612053828201612963565b83815282810190868401838801850189101561206e57600080fd5b600093505b85841015612091578035835260019390930192918401918401612073565b50979650505050505050565b600082601f8301126120ae57600080fd5b81356001600160401b038111156120c7576120c7612ad1565b6120da601f8201601f1916602001612963565b8181528460208386010111156120ef57600080fd5b816020850160208301376000918101602001919091529392505050565b6000611c00828403121561211f57600080fd5b612127612941565b90508151815261213a836020840161218b565b602082015261214d83610de0840161218b565b6040820152611ba08201516060820152611bc082015161216c81612b0c565b6080820152611be082015161218081612b0c565b60a082015292915050565b6000818303610dc081121561219f57600080fd5b6121a761291f565b915082516121b481612af7565b8252602083810151908301526105e0603f19820112156121d357600080fd5b6121db612941565b604084015181526060840151602082015260c0607f19830112156121fe57600080fd5b612206612941565b91506080840151825260a0840151602083015260c0840151604083015260e08401516060830152610100840151608083015261012084015160a0830152816040820152612257856101408601611faa565b60608201526102408401516080820152612275856102608601611e34565b60a082015260408301525061228e836106208401611f31565b6060820152610da0820151608082015292915050565b805161ffff811681146122b657600080fd5b919050565b6000602082840312156122cd57600080fd5b81356122d881612af7565b9392505050565b6000602082840312156122f157600080fd5b81516122d881612af7565b600080600080600060a0868803121561231457600080fd5b853561231f81612af7565b9450602086013561232f81612af7565b935060408601356001600160401b038082111561234b57600080fd5b61235789838a01612018565b9450606088013591508082111561236d57600080fd5b61237989838a01612018565b9350608088013591508082111561238f57600080fd5b5061239c8882890161209d565b9150509295509295909350565b600080600080608085870312156123bf57600080fd5b84356123ca81612af7565b935060208501356123da81612af7565b92506040850135915060608501356001600160401b038111156123fc57600080fd5b6124088782880161209d565b91505092959194509250565b600080600080600060a0868803121561242c57600080fd5b853561243781612af7565b9450602086013561244781612af7565b9350604086013592506060860135915060808601356001600160401b0381111561247057600080fd5b61239c8882890161209d565b60006020828403121561248e57600080fd5b813580151581146122d857600080fd5b6000602082840312156124b057600080fd5b81356001600160e01b0319811681146122d857600080fd5b600080611c2083850312156124dc57600080fd5b6124e6848461210c565b9150611c008301516124f781612af7565b809150509250929050565b600080611c20838503121561251657600080fd5b612520848461210c565b9150611c0083015190509250929050565b60006020828403121561254357600080fd5b5035919050565b60006020828403121561255c57600080fd5b5051919050565b6000806040838503121561257657600080fd5b50508035926020909101359150565b6000806040838503121561259857600080fd5b505080516020909101519092909150565b8060005b6005811015612635578151805185526020808201519150815160010b8187015280820151604061ffff808316828a015281850151925060609150600683106125f7576125f7612a8f565b888201929092528301519060809061260e83612ae7565b88820192909252929092015190911660a086015260c09094019391909101906001016125ad565b50505050565b8060005b603c81101561263557815184526020938401939091019060010161263f565b8060005b6008811015612635578151845260209384019390910190600101612662565b60018060a01b0381511682526020810151602083015260408101518051604084015260208101516060840152604081015180516080850152602081015160a0850152604081015160c0850152606081015160e0850152608081015161010085015260a081015161012085015250606081015161270161014085018261265e565b50608081015161024084015260a0015161271f6102608401826125a9565b50606081015161273361062084018261263b565b5060800151610da09190910152565b604080825283519082018190526000906020906060840190828701845b828110156127845781516001600160a01b03168452928401929084019060010161275f565b5050508381038285015284518082528583019183019060005b818110156127b95783518352928401929184019160010161279d565b5090979650505050505050565b60208082526025908201527f506570656d6f6e4d617463686d616b65723a20496e76616c696420626174746c6040820152641958d85c9960da1b606082015260800190565b6020808252602b908201527f506570656d6f6e4d617463686d616b65723a204e6f7420656e6f75676820737560408201526a70706f727420636172647360a81b606082015260800190565b6020808252818101527f506570656d6f6e4d617463686d616b65723a204e6f7420796f7572206465636b604082015260600190565b81518152602080830151611c008301916128a790840182612681565b5060408301516128bb610de0840182612681565b506060830151611ba083015260808301516128d581612ae7565b611bc083015260a08301516128e981612ae7565b80611be08401525092915050565b604080519081016001600160401b038111828210171561291957612919612ad1565b60405290565b60405160a081016001600160401b038111828210171561291957612919612ad1565b60405160c081016001600160401b038111828210171561291957612919612ad1565b604051601f8201601f191681016001600160401b038111828210171561298b5761298b612ad1565b604052919050565b600082198211156129a6576129a6612a63565b500190565b6000826129ba576129ba612a79565b500490565b60008160001904831182151516156129d9576129d9612a63565b500290565b60008083128015600160ff1b8501841216156129fc576129fc612a63565b6001600160ff1b0384018313811615612a1757612a17612a63565b50500390565b600082821015612a2f57612a2f612a63565b500390565b6000600019821415612a4857612a48612a63565b5060010190565b600082612a5e57612a5e612a79565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600281106109d1576109d1612a8f565b6001600160a01b03811681146109d157600080fd5b600281106109d157600080fdfea2646970667358221220da53cd4092cb817bb4f1dd5f902c186cf7f337810a46e7737b8a6fb07915bc4164736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c8063889f004711610104578063b24cf5d7116100a2578063e19e89ab11610071578063e19e89ab1461042f578063f23a6e6114610441578063fa6285cc14610460578063fd12a4d21461048157600080fd5b8063b24cf5d7146103c1578063bc197c81146103d4578063d671581f146103f3578063d8963fc41461041c57600080fd5b80638bad0c0a116100de5780638bad0c0a1461037357806396dc76c41461037b578063a59f3e0c1461039b578063b2152aed146103ae57600080fd5b8063889f00471461032d5780638a062ab7146103585780638a78c3401461036b57600080fd5b8063458870381161017157806364375d291161014b57806364375d29146102e157806370480275146102f45780637f8661a11461030757806386db4df71461031a57600080fd5b8063458870381461029357806346864cd8146102a657806359509b7a146102b957600080fd5b8063150b7a02116101ad578063150b7a021461022457806324d7806c1461025b5780632acc9a9c1461026e5780633174d5071461028157600080fd5b806301ffc9a7146101d4578063086f99d4146101fc5780630a96263214610211575b600080fd5b6101e76101e236600461249e565b610494565b60405190151581526020015b60405180910390f35b61020f61020a3660046122bb565b6104cb565b005b61020f61021f36600461247c565b6104ff565b6102426102323660046123a9565b630a85bd0160e11b949350505050565b6040516001600160e01b031990911681526020016101f3565b6101e76102693660046122bb565b61052f565b61020f61027c366004612531565b61053b565b6009545b6040519081526020016101f3565b61020f6102a1366004612563565b61091c565b61020f6102b43660046122bb565b610939565b6102cc6102c7366004612531565b61096d565b604080519283526020830191909152016101f3565b6102856102ef366004612563565b61099b565b61020f6103023660046122bb565b6109b6565b61020f610315366004612531565b6109d4565b61020f610328366004612531565b610abe565b61034061033b366004612531565b610b7a565b6040516001600160a01b0390911681526020016101f3565b61020f610366366004612531565b610ba4565b600b54610285565b61020f610bbb565b6102856103893660046122bb565b600a6020526000908152604090205481565b61020f6103a9366004612531565b610bc6565b61020f6103bc366004612531565b610f49565b61020f6103cf3660046122bb565b610f76565b6102426103e23660046122fc565b63bc197c8160e01b95945050505050565b610340610401366004612531565b6008602052600090815260409020546001600160a01b031681565b61020f61042a36600461247c565b610faa565b600354600160a81b900460ff166101e7565b61024261044f366004612414565b63f23a6e6160e01b95945050505050565b61047361046e366004612563565b610fda565b6040516101f3929190612742565b61020f61048f366004612531565b611188565b60006001600160e01b03198216630271189760e51b14806104c557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6104d43361052f565b6104dd57600080fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6105083361052f565b61051157600080fd5b60038054911515600160a81b0260ff60a81b19909216919091179055565b60006104c581836111e6565b6002546040516331a9108f60e11b8152600481018390526001600160a01b0390911690636352211e9060240160206040518083038186803b15801561057f57600080fd5b505afa158015610593573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b791906122df565b6001600160a01b0316336001600160a01b0316146105f05760405162461bcd60e51b81526004016105e790612856565b60405180910390fd5b6002546040516352637b1f60e11b8152600481018390526001600160a01b039091169063a4c6f63e9060240160206040518083038186803b15801561063457600080fd5b505afa158015610648573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066c919061254a565b6106885760405162461bcd60e51b81526004016105e7906127c6565b600354600160a81b900460ff1615156001146106f25760405162461bcd60e51b8152602060048201526024808201527f506570656d6f6e4d617463686d616b65723a20507645206d6f64652064697361604482015263189b195960e21b60648201526084016105e7565b60025460405163a090195d60e01b8152600481018390526000916001600160a01b03169063a090195d90602401604080518083038186803b15801561073657600080fd5b505afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190612585565b915050600260009054906101000a90046001600160a01b03166001600160a01b03166330ecf94e6040518163ffffffff1660e01b815260040160206040518083038186803b1580156107bf57600080fd5b505afa1580156107d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f7919061254a565b8110156108165760405162461bcd60e51b81526004016105e79061280b565b336000908152600a602052604090205461089c57336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b60006108a78361121b565b905080156108be576108b983826112a0565b505050565b60405162461bcd60e51b815260206004820152602d60248201527f506570656d6f6e4d617463686d616b65723a204e6f20507645206f70706f6e6560448201526c6e747320617661696c61626c6560981b60648201526084016105e7565b6109253361052f565b61092e57600080fd5b600491909155600555565b6109423361052f565b61094b57600080fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6009818154811061097d57600080fd5b60009182526020909120600290910201805460019091015490915082565b6000806109ad84846064600654611466565b50949350505050565b6109bf3361052f565b6109c857600080fd5b6109d1816115ac565b50565b60095415801590610a1b5750600081815260076020526040902054600980549091908110610a0457610a04612abb565b906000526020600020906002020160000154600014155b610a7f5760405162461bcd60e51b815260206004820152602f60248201527f506570656d6f6e4d617463686d616b65723a204465636b206973206e6f74206960448201526e1b881d1a19481dd85a5d081b1a5cdd608a1b60648201526084016105e7565b6000818152600860205260409020546001600160a01b03163314610ab55760405162461bcd60e51b81526004016105e790612856565b6109d1816115ee565b610ac73361052f565b610ad057600080fd5b600354600160a81b900460ff161515600114610aeb57600080fd5b336000908152600a6020526040902054610b7157336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b6109d181611795565b600b8181548110610b8a57600080fd5b6000918252602090912001546001600160a01b0316905081565b610bad3361052f565b610bb657600080fd5b600655565b610bc4336118b9565b565b6002546040516331a9108f60e11b8152600481018390526001600160a01b0390911690636352211e9060240160206040518083038186803b158015610c0a57600080fd5b505afa158015610c1e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4291906122df565b6001600160a01b0316336001600160a01b031614610c725760405162461bcd60e51b81526004016105e790612856565b6002546040516352637b1f60e11b8152600481018390526001600160a01b039091169063a4c6f63e9060240160206040518083038186803b158015610cb657600080fd5b505afa158015610cca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cee919061254a565b610d0a5760405162461bcd60e51b81526004016105e7906127c6565b600354600160a81b900460ff1615610d705760405162461bcd60e51b815260206004820152602360248201527f506570656d6f6e4d617463686d616b65723a20507645206d6f646520656e61626044820152621b195960ea1b60648201526084016105e7565b60025460405163a090195d60e01b8152600481018390526000916001600160a01b03169063a090195d90602401604080518083038186803b158015610db457600080fd5b505afa158015610dc8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dec9190612585565b915050600260009054906101000a90046001600160a01b03166001600160a01b03166330ecf94e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e3d57600080fd5b505afa158015610e51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e75919061254a565b811015610e945760405162461bcd60e51b81526004016105e79061280b565b336000908152600a6020526040902054610f1a57336000818152600a602052604081207f00000000000000000000000000000000000000000000000000000000000000009055600b805460018101825591527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90180546001600160a01b03191690911790555b6000610f25836118fb565b90508015610f4057610f3783826112a0565b6108b9816115ee565b6108b983611795565b610f523361052f565b610f5b57600080fd5b600354600160a81b900460ff161515600114610ab557600080fd5b610f7f3361052f565b610f8857600080fd5b600380546001600160a01b0319166001600160a01b0392909216919091179055565b610fb33361052f565b610fbc57600080fd5b60038054911515600160a01b0260ff60a01b19909216919091179055565b600b54606090819083106110215760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a59081bd9999cd95d60921b60448201526064016105e7565b600b5461102e8486612a1d565b111561103a57600b5493505b836001600160401b0381111561105257611052612ad1565b60405190808252806020026020018201604052801561107b578160200160208202803683370190505b509150836001600160401b0381111561109657611096612ad1565b6040519080825280602002602001820160405280156110bf578160200160208202803683370190505b509050825b6110ce8585612993565b811015611180576000600b82815481106110ea576110ea612abb565b6000918252602090912001546001600160a01b03169050808461110d8785612a1d565b8151811061111d5761111d612abb565b6001600160a01b039283166020918202929092018101919091529082166000908152600a9091526040902054836111548785612a1d565b8151811061116457611164612abb565b60209081029190910101525061117981612a34565b90506110c4565b509250929050565b6111913361052f565b610ab557600080fd5b6001600160a01b0381166111ad57600080fd5b6111b782826111e6565b156111c157600080fd5b6001600160a01b0316600090815260209190915260409020805460ff19166001179055565b60006001600160a01b0382166111fb57600080fd5b506001600160a01b03166000908152602091909152604090205460ff1690565b60095460009061122d57506000919050565b60095460408051603f6020820152908101849052426060820152600091906080016040516020818303038152906040528051906020012060001c6112719190612a4f565b90506009818154811061128657611286612abb565b906000526020600020906002020160000154915050919050565b60008060006112af8585611ac1565b925092509250816001600160a01b0316836001600160a01b03167f9b5363c49f40791b738dbe0ba63e6fa52ed52213cf8d4a2f3724e1389d72f14f836040516112fa91815260200190565b60405180910390a36003546040516331f27b0760e01b8152600481018390526001600160a01b038581166024830152909116906331f27b0790604401600060405180830381600087803b15801561135057600080fd5b505af1158015611364573d6000803e3d6000fd5b5050506001600160a01b038085166000908152600a60205260408082205492861682528120549092506064916113999161099b565b6113a391906129ab565b6001600160a01b0385166000908152600a60205260408120805492935083929091906113d0908490612993565b90915550506001600160a01b0383166000908152600a60205260408120546113f99083906129de565b1315611441576001600160a01b0383166000908152600a6020526040902054611423908290612a1d565b6001600160a01b0384166000908152600a602052604090205561145e565b6001600160a01b0383166000908152600a60205260409020600190555b505050505050565b6000806127108302868610828161147f57888803611483565b8789035b905061046681106114d65760405162461bcd60e51b815260206004820152601b60248201527f526174696e6720646966666572656e636520746f6f206c61726765000000000060448201526064016105e7565b811561152d57610320811061152d5760405162461bcd60e51b815260206004820152601b60248201527f526174696e6720646966666572656e636520746f6f206c61726765000000000060448201526064016105e7565b60008060008060008661154457856103200161154a565b85610320035b945061155c600a601987046001611c3c565b935061156784611cfa565b925082606401888161157b5761157b612a79565b0491508b8b02905081811098508861159557818103611599565b8082035b9950505050505050505094509492505050565b6115b760008261119a565b6040516001600160a01b038216907f44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e33990600090a250565b600254600082815260086020526040808220549051635c46a7ef60e11b81523060048201526001600160a01b039182166024820152604481018590526080606482015260848101929092529091169063b88d4fde9060a401600060405180830381600087803b15801561166057600080fd5b505af1158015611674573d6000803e3d6000fd5b505050600082815260086020526040812080546001600160a01b03191690556009549091506116a590600190612a1d565b90506000600982815481106116bc576116bc612abb565b6000918252602080832060029092029091015485835260079091526040808320548284529220919091556009805491925090839081106116fe576116fe612abb565b9060005260206000209060020201600960076000868152602001908152602001600020548154811061173257611732612abb565b600091825260209091208254600290920201908155600191820154910155600980548061176157611761612aa5565b6000828152602080822060026000199094019384020182815560010182905591909255938152600790935250506040812055565b60008181526008602052604080822080546001600160a01b031916339081179091556002549151635c46a7ef60e11b81526004810191909152306024820152604481018490526080606482015260848101929092526001600160a01b03169063b88d4fde9060a401600060405180830381600087803b15801561181757600080fd5b505af115801561182b573d6000803e3d6000fd5b505060098054600085815260076020908152604080832084905580518082019091529687524290870190815260018301845592905293517f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af600290950294850155517f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7b0909301929092555050565b6118c4600082611d13565b6040516001600160a01b038216907fa3b62bc36326052d97ea62d63c3d60308ed4c3ea8ac079dd8499f1e9c4f80c0f90600090a250565b6000805b600954811015611ab85760006009828154811061191e5761191e612abb565b90600052602060002090600202016000015490508382148061196b5750600354600160a01b900460ff1615801561196b57506000818152600860205260409020546001600160a01b031633145b156119765750611aa8565b6000603c6009848154811061198d5761198d612abb565b906000526020600020906002020160010154426119aa9190612a1d565b6119b59060786129bf565b6119bf91906129ab565b905060006078600554836119d391906129bf565b6119dd91906129ab565b6004546119ea9190612993565b6000848152600860209081526040808320546001600160a01b03168352600a9091528082205433835291205491925090611a25908390612993565b118015611a6f57506000838152600860209081526040808320546001600160a01b03168352600a909152902054611a5d908290612993565b336000908152600a6020526040902054105b15611aa45760098481548110611a8757611a87612abb565b906000526020600020906002020160000154945050505050919050565b5050505b611ab181612a34565b90506118ff565b50600092915050565b6001546000828152600860205260408082205490516331acd38760e21b8152336004820152602481018690526001600160a01b039182166044820152606481018590529192839283928392839291169063c6b34e1c90608401611c2060405180830381600087803b158015611b3557600080fd5b505af1158015611b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b6d9190612502565b600154604051637cdb32cd60e01b81529294509092506000916001600160a01b0390911690637cdb32cd90611ba690869060040161288b565b611c206040518083038186803b158015611bbf57600080fd5b505afa158015611bd3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bf791906124c8565b9150600090506001600160a01b0382163314611c135733611c2c565b6000888152600860205260409020546001600160a01b03165b9199919850919650945050505050565b6000838015611cdc57600184168015611c5757859250611c5b565b8392505b508260011c8460011c94505b8415611cd6578560801c15611c7b57600080fd5b85860281810181811015611c8e57600080fd5b8590049650506001851615611ccb578583028387820414611cb4578615611cb457600080fd5b81810181811015611cc457600080fd5b8590049350505b8460011c9450611c67565b50611cf2565b838015611cec5760009250611cf0565b8392505b505b509392505050565b60006104c5611d0e611d0e611d0e85611d5b565b611d5b565b6001600160a01b038116611d2657600080fd5b611d3082826111e6565b611d3957600080fd5b6001600160a01b0316600090815260209190915260409020805460ff19169055565b600181600160801b8110611d745760409190911b9060801c5b680100000000000000008110611d8f5760209190911b9060401c5b6401000000008110611da65760109190911b9060201c5b620100008110611dbb5760089190911b9060101c5b6101008110611dcf5760049190911b9060081c5b60108110611de25760029190911b9060041c5b60088110611df1578160011b91505b5080820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c80820481811015611e2e578091505b50919050565b600082601f830112611e4557600080fd5b611e4d61291f565b8083856103c086011115611e6057600080fd5b60005b6005811015611f265781870360c080821215611e7e57600080fd5b611e866128f7565b84518152602060a080601f1986011215611e9f57600080fd5b611ea761291f565b9450818701518060010b8114611ebc57600080fd5b85526040611ecb8882016122a4565b8387015260608089015160068110611ee257600080fd5b8083890152506080915081890151611ef981612b0c565b90870152611f088883016122a4565b90860152508181019390935286529401939190910190600101611e63565b509095945050505050565b600082601f830112611f4257600080fd5b6040516107808082018281106001600160401b0382111715611f6657611f66612ad1565b6040528184828101871015611f7a57600080fd5b600092505b603c831015611f9f57805182526001929092019160209182019101611f7f565b509195945050505050565b600082601f830112611fbb57600080fd5b6040516101008082018281106001600160401b0382111715611fdf57611fdf612ad1565b6040528184828101871015611ff357600080fd5b600092505b6008831015611f9f57805182526001929092019160209182019101611ff8565b600082601f83011261202957600080fd5b813560206001600160401b0382111561204457612044612ad1565b8160051b612053828201612963565b83815282810190868401838801850189101561206e57600080fd5b600093505b85841015612091578035835260019390930192918401918401612073565b50979650505050505050565b600082601f8301126120ae57600080fd5b81356001600160401b038111156120c7576120c7612ad1565b6120da601f8201601f1916602001612963565b8181528460208386010111156120ef57600080fd5b816020850160208301376000918101602001919091529392505050565b6000611c00828403121561211f57600080fd5b612127612941565b90508151815261213a836020840161218b565b602082015261214d83610de0840161218b565b6040820152611ba08201516060820152611bc082015161216c81612b0c565b6080820152611be082015161218081612b0c565b60a082015292915050565b6000818303610dc081121561219f57600080fd5b6121a761291f565b915082516121b481612af7565b8252602083810151908301526105e0603f19820112156121d357600080fd5b6121db612941565b604084015181526060840151602082015260c0607f19830112156121fe57600080fd5b612206612941565b91506080840151825260a0840151602083015260c0840151604083015260e08401516060830152610100840151608083015261012084015160a0830152816040820152612257856101408601611faa565b60608201526102408401516080820152612275856102608601611e34565b60a082015260408301525061228e836106208401611f31565b6060820152610da0820151608082015292915050565b805161ffff811681146122b657600080fd5b919050565b6000602082840312156122cd57600080fd5b81356122d881612af7565b9392505050565b6000602082840312156122f157600080fd5b81516122d881612af7565b600080600080600060a0868803121561231457600080fd5b853561231f81612af7565b9450602086013561232f81612af7565b935060408601356001600160401b038082111561234b57600080fd5b61235789838a01612018565b9450606088013591508082111561236d57600080fd5b61237989838a01612018565b9350608088013591508082111561238f57600080fd5b5061239c8882890161209d565b9150509295509295909350565b600080600080608085870312156123bf57600080fd5b84356123ca81612af7565b935060208501356123da81612af7565b92506040850135915060608501356001600160401b038111156123fc57600080fd5b6124088782880161209d565b91505092959194509250565b600080600080600060a0868803121561242c57600080fd5b853561243781612af7565b9450602086013561244781612af7565b9350604086013592506060860135915060808601356001600160401b0381111561247057600080fd5b61239c8882890161209d565b60006020828403121561248e57600080fd5b813580151581146122d857600080fd5b6000602082840312156124b057600080fd5b81356001600160e01b0319811681146122d857600080fd5b600080611c2083850312156124dc57600080fd5b6124e6848461210c565b9150611c008301516124f781612af7565b809150509250929050565b600080611c20838503121561251657600080fd5b612520848461210c565b9150611c0083015190509250929050565b60006020828403121561254357600080fd5b5035919050565b60006020828403121561255c57600080fd5b5051919050565b6000806040838503121561257657600080fd5b50508035926020909101359150565b6000806040838503121561259857600080fd5b505080516020909101519092909150565b8060005b6005811015612635578151805185526020808201519150815160010b8187015280820151604061ffff808316828a015281850151925060609150600683106125f7576125f7612a8f565b888201929092528301519060809061260e83612ae7565b88820192909252929092015190911660a086015260c09094019391909101906001016125ad565b50505050565b8060005b603c81101561263557815184526020938401939091019060010161263f565b8060005b6008811015612635578151845260209384019390910190600101612662565b60018060a01b0381511682526020810151602083015260408101518051604084015260208101516060840152604081015180516080850152602081015160a0850152604081015160c0850152606081015160e0850152608081015161010085015260a081015161012085015250606081015161270161014085018261265e565b50608081015161024084015260a0015161271f6102608401826125a9565b50606081015161273361062084018261263b565b5060800151610da09190910152565b604080825283519082018190526000906020906060840190828701845b828110156127845781516001600160a01b03168452928401929084019060010161275f565b5050508381038285015284518082528583019183019060005b818110156127b95783518352928401929184019160010161279d565b5090979650505050505050565b60208082526025908201527f506570656d6f6e4d617463686d616b65723a20496e76616c696420626174746c6040820152641958d85c9960da1b606082015260800190565b6020808252602b908201527f506570656d6f6e4d617463686d616b65723a204e6f7420656e6f75676820737560408201526a70706f727420636172647360a81b606082015260800190565b6020808252818101527f506570656d6f6e4d617463686d616b65723a204e6f7420796f7572206465636b604082015260600190565b81518152602080830151611c008301916128a790840182612681565b5060408301516128bb610de0840182612681565b506060830151611ba083015260808301516128d581612ae7565b611bc083015260a08301516128e981612ae7565b80611be08401525092915050565b604080519081016001600160401b038111828210171561291957612919612ad1565b60405290565b60405160a081016001600160401b038111828210171561291957612919612ad1565b60405160c081016001600160401b038111828210171561291957612919612ad1565b604051601f8201601f191681016001600160401b038111828210171561298b5761298b612ad1565b604052919050565b600082198211156129a6576129a6612a63565b500190565b6000826129ba576129ba612a79565b500490565b60008160001904831182151516156129d9576129d9612a63565b500290565b60008083128015600160ff1b8501841216156129fc576129fc612a63565b6001600160ff1b0384018313811615612a1757612a17612a63565b50500390565b600082821015612a2f57612a2f612a63565b500390565b6000600019821415612a4857612a48612a63565b5060010190565b600082612a5e57612a5e612a79565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600281106109d1576109d1612a8f565b6001600160a01b03811681146109d157600080fd5b600281106109d157600080fdfea2646970667358221220da53cd4092cb817bb4f1dd5f902c186cf7f337810a46e7737b8a6fb07915bc4164736f6c63430008060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "enter(uint256)": {
        "details": "This function cannot be used if _pveMode is set to true, players should join using \"enterPve\" instead.",
        "params": {
          "deckId": "The Deck of who called this function"
        }
      },
      "enterPve(uint256)": {
        "details": "This function cannot be used if _pveMode is set to false. In that case, players should join using \"enter\" instead, which  allows them to fight each other.",
        "params": {
          "deckId": "The Deck of who called this function"
        }
      },
      "exit(uint256)": {
        "params": {
          "deckId": "The Deck of the owner"
        }
      },
      "getEloRatingChange(uint256,uint256)": {
        "details": "The returned number has 2 decimals of precision, so 1501 = 15.01 Elo change"
      },
      "getPlayersRankings(uint256,uint256)": {
        "details": "Returns the rankings and addresses of players on the leaderboard, within a given range of indices.Requires that `count` is less than or equal to the number of players on the leaderboard minus `offset`, and that `offset` is less than the number of players on the leaderboard.",
        "params": {
          "count": "The number of rankings to return.",
          "offset": "The index of the first ranking to return."
        },
        "returns": {
          "addresses": "An array of player addresses corresponding to the returned rankings.",
          "rankings": "An array of ranking values for the returned players."
        }
      },
      "leaderboardPlayersCount()": {
        "details": "Returns the number of players currently on the leaderboard.",
        "returns": {
          "_0": "The number of players currently on the leaderboard."
        }
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "details": "See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."
      },
      "setKFactor(uint256)": {
        "details": "Dictates the rate of change, has a direct influence on how much a player wins/loses in the ranking",
        "params": {
          "kFactor": "Value used to calculate the rate of change in getEloRatingChange"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "enter(uint256)": {
        "notice": "Tries to initiate a battle using a specified deck. If no opponents are found, the deck is placed in a wait list."
      },
      "enterPve(uint256)": {
        "notice": "Tries to initiate a battle using a specified deck. Opponents are not other players but a set of decks added by admins."
      },
      "exit(uint256)": {
        "notice": "Transfers a deck back to its owner and removes from the wait list"
      },
      "getEloRatingChange(uint256,uint256)": {
        "notice": "Calculates the Elo change based on the winner's and loser's ratings."
      },
      "getWaitingCount()": {
        "notice": "Retrieves the number of waiting decks"
      },
      "isPveMode()": {
        "notice": "Tells whether or not this contract is operating in PvE mode. When in PvE mode, players cannot fight against each other (because PvE is the opposite of PvP)."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7509,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "admins",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(Role)8015_storage"
      },
      {
        "astId": 6208,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_battleAddress",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 6210,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_deckAddress",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 6212,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_rewardPoolAddress",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 6214,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_allowBattleAgainstOneself",
        "offset": 20,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 6216,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_pveMode",
        "offset": 21,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 6221,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_matchRange",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 6224,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_matchRangePerMinute",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 6227,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_kFactor",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 6231,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "_waitingDecksIndex",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 6235,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "deckOwner",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 6239,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "waitingDecks",
        "offset": 0,
        "slot": "9",
        "type": "t_array(t_struct(waitingDeckData)6206_storage)dyn_storage"
      },
      {
        "astId": 6243,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "playerRanking",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 6246,
        "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
        "label": "leaderboardPlayers",
        "offset": 0,
        "slot": "11",
        "type": "t_array(t_address)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(waitingDeckData)6206_storage)dyn_storage": {
        "base": "t_struct(waitingDeckData)6206_storage",
        "encoding": "dynamic_array",
        "label": "struct PepemonMatchmaker.waitingDeckData[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Role)8015_storage": {
        "encoding": "inplace",
        "label": "struct Roles.Role",
        "members": [
          {
            "astId": 8014,
            "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
            "label": "bearer",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(waitingDeckData)6206_storage": {
        "encoding": "inplace",
        "label": "struct PepemonMatchmaker.waitingDeckData",
        "members": [
          {
            "astId": 6203,
            "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
            "label": "deckId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6205,
            "contract": "contracts/PepemonMatchmaker.sol:PepemonMatchmaker",
            "label": "enterTimestamp",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}